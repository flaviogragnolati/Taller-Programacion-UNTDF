# MÃ³dulo 5: Entradas/Salidas y Conectividad
## **Tema 5.2:** Consumo de APIs (`requests`), autenticaciÃ³n bÃ¡sica

> Objetivo: aprender a **consumir APIs HTTP/REST** desde Python con la librerÃ­a `requests`, comprender los **mÃ©todos HTTP**, manejar **parÃ¡metros, headers y JSON**, implementar **timeouts y reintentos**, y aplicar **autenticaciÃ³n bÃ¡sica** (Basic, tokens tipo *Bearer*, API keys). Incluye ejemplos prÃ¡cticos y buenas prÃ¡cticas.

---

### ðŸ“¦ Dependencias
- **Requerido:** `requests`
- **Opcional (recomendado):** `python-dotenv` (gestiÃ³n de secretos), `pydantic` (validaciÃ³n de respuestas JSON)

```bash
pip install requests python-dotenv pydantic
```

---

## 1) AnatomÃ­a rÃ¡pida de HTTP/REST

- **MÃ©todos**: `GET` (leer), `POST` (crear), `PUT/PATCH` (actualizar), `DELETE` (eliminar), `HEAD/OPTIONS` (meta).
- **URL**: `https://api.servidor.com/recurso/{id}?limit=50&offset=0`
- **Headers**: metadatos (p. ej. `Authorization`, `Accept`, `Content-Type`).
- **Body**: datos enviados (JSON, formulario, multipart).
- **CÃ³digos de estado**: `2xx` ok, `4xx` error del cliente, `5xx` error del servidor.
- **Formato**: JSON es el mÃ¡s comÃºn (`application/json`).

---

## 2) Primeros pasos con `requests`

```python
import requests

BASE_URL = "https://jsonplaceholder.typicode.com"

# GET simple
r = requests.get(f"{BASE_URL}/posts/1", timeout=10)  # segundos
r.raise_for_status()  # lanza HTTPError si 4xx/5xx
data = r.json()      # parsea JSON a dict
print(data["title"])

# GET con parÃ¡metros (query string)
params = {"userId": 1, "_limit": 5}
r = requests.get(f"{BASE_URL}/posts", params=params, timeout=10)
print(r.url)      # URL final con query
print(r.json())

# POST enviando JSON
payload = {"title": "Nuevo post", "body": "contenido", "userId": 1}
r = requests.post(f"{BASE_URL}/posts", json=payload, timeout=10)
print(r.status_code, r.json())
```

**Notas:**
- Usa `timeout` **siempre** (tuple opcional: `timeout=(conectar, leer)`).
- Usa `raise_for_status()` para atajar errores temprano.
- Para formularios: `requests.post(url, data={"campo": "valor"})`.
- Para subir archivos: `files={"archivo": ("reporte.csv", open("reporte.csv","rb"), "text/csv")}`.

---

## 3) ParÃ¡metros, headers y cuerpos

```python
import requests

url = "https://httpbin.org/anything"

params = {"page": 2, "limit": 50}
headers = {
    "Accept": "application/json",
    "User-Agent": "TallerPython/1.0",
}

# Enviar JSON en el body
payload = {"filtro": {"desde": "2025-01-01", "hasta": "2025-12-31"}}

r = requests.post(url, params=params, headers=headers, json=payload, timeout=10)
r.raise_for_status()
print(r.json())
```

**Tipos de `Content-Type` comunes:**
- `application/json`: usar `json=payload`
- `application/x-www-form-urlencoded`: usar `data=payload`
- `multipart/form-data`: usar `files=...` (subidas de archivos)

---

## 4) AutenticaciÃ³n bÃ¡sica y variantes habituales

### 4.1 Basic Auth (usuario/contraseÃ±a)
```python
import requests
from requests.auth import HTTPBasicAuth

url = "https://httpbin.org/basic-auth/user123/secret456"
r = requests.get(url, auth=HTTPBasicAuth("user123", "secret456"), timeout=10)
print(r.status_code, r.json())
```

> Atajo: `auth=("user123","secret456")` funciona igual.

### 4.2 Tokens tipo *Bearer*
```python
import os, requests

token = os.getenv("API_TOKEN")  # cargar desde variable de entorno
headers = {"Authorization": f"Bearer {token}"}

r = requests.get("https://api.ejemplo.com/v1/me", headers=headers, timeout=10)
r.raise_for_status()
perfil = r.json()
```

### 4.3 API Keys (en header o query)
```python
import os, requests

api_key = os.getenv("API_KEY")
headers = {"X-API-Key": api_key}

# A veces va en la query (?api_key=...)
r = requests.get("https://api.ejemplo.com/data", headers=headers, timeout=10)
```

**Buenas prÃ¡cticas de secretos:**
- Cargar claves desde **variables de entorno** o un `.env` (con `python-dotenv`).
- No subir secretos a Git. AÃ±adir `.env` a `.gitignore`.
- Rotar y limitar permisos (principio de mÃ­nimo privilegio).

**Ejemplo `.env`:**
```
API_TOKEN=tu_token_aqui
API_KEY=tu_api_key_aqui
```
```python
# cargar .env
from dotenv import load_dotenv; load_dotenv()
```

---

## 5) Sesiones, timeouts y reintentos

### 5.1 `Session`: reutilizar conexiÃ³n y headers
```python
import requests

session = requests.Session()
session.headers.update({"Accept": "application/json", "User-Agent": "TallerPython/1.0"})

r = session.get("https://jsonplaceholder.typicode.com/users", timeout=10)
print(len(r.json()))

# Para headers por request, puedes sobrescribir:
r = session.get("https://jsonplaceholder.typicode.com/posts", headers={"X-Trace": "1"}, timeout=10)
```

### 5.2 Reintentos con backoff (errores transitorios)
```python
import requests
from urllib3.util.retry import Retry
from requests.adapters import HTTPAdapter

session = requests.Session()
retry = Retry(
    total=5,
    backoff_factor=0.5,             # 0.5, 1, 2, 4â€¦ (exponencial)
    status_forcelist=[429, 500, 502, 503, 504],
    allowed_methods=["GET","POST","PUT","PATCH","DELETE"],
)
adapter = HTTPAdapter(max_retries=retry)
session.mount("https://", adapter)
session.mount("http://", adapter)

r = session.get("https://httpbin.org/status/503", timeout=(3, 10))
print(r.status_code)
```

**Tip:** respeta `Retry-After` si la API lo devuelve (rate limiting).

---

## 6) PaginaciÃ³n y filtrado

### 6.1 PaginaciÃ³n por `page`/`limit`
```python
import requests

url = "https://jsonplaceholder.typicode.com/comments"
page, limit = 1, 100
todos = []

while True:
    r = requests.get(url, params={"_page": page, "_limit": limit}, timeout=10)
    r.raise_for_status()
    lote = r.json()
    if not lote:
        break
    todos.extend(lote)
    page += 1

print("Total:", len(todos))
```

### 6.2 PaginaciÃ³n por `next` (estilo HATEOAS)
```python
import requests

url = "https://api.ejemplo.com/items"
results = []
while url:
    r = requests.get(url, timeout=10)
    r.raise_for_status()
    payload = r.json()
    results.extend(payload["results"])
    url = payload.get("next")  # o r.links.get("next", {}).get("url")
```

---

## 7) Descargas y subidas de archivos

### 7.1 Descargar grande en streaming
```python
import requests

url = "https://speed.hetzner.de/100MB.bin"
with requests.get(url, stream=True, timeout=30) as r:
    r.raise_for_status()
    with open("descarga.bin", "wb") as f:
        for chunk in r.iter_content(chunk_size=8192):
            if chunk:
                f.write(chunk)
```

### 7.2 Subir un archivo (multipart/form-data)
```python
import requests

url = "https://httpbin.org/post"
files = {"file": ("datos.csv", open("datos.csv","rb"), "text/csv")}
r = requests.post(url, files=files, timeout=30)
print(r.json()["files"].keys())
```

---

## 8) Manejo de errores y validaciÃ³n de respuestas

```python
import requests

def get_json(url, **kwargs):
    try:
        r = requests.get(url, timeout=kwargs.pop("timeout", 10), **kwargs)
        r.raise_for_status()
        return r.json()
    except requests.exceptions.Timeout:
        raise RuntimeError("Timeout al consultar la API")
    except requests.exceptions.HTTPError as e:
        status = e.response.status_code
        detalle = e.response.text[:200]
        raise RuntimeError(f"Error HTTP {status}: {detalle}")
    except requests.exceptions.RequestException as e:
        raise RuntimeError(f"Error de red: {e}")

data = get_json("https://jsonplaceholder.typicode.com/users")
```

**Validar con `pydantic` (opcional):**
```python
from pydantic import BaseModel, ValidationError
from typing import List

class User(BaseModel):
    id: int
    name: str
    email: str

try:
    users = [User(**u) for u in data]
except ValidationError as e:
    print("Respuesta inesperada:", e)
```

---

## 9) Seguridad y buenas prÃ¡cticas

- **No** deshabilitar SSL (`verify=False`) salvo diagnÃ³stico puntual.
- Mantener **timeouts** y **reintentos**: robustez ante caÃ­das.
- **Backoff exponencial** + respeto de `429` / `Retry-After`.
- **Limitar** datos sensibles en logs. Sanitizar.
- Usar **.env/variables** de entorno y **.gitignore** para secretos.
- Documentar **versiones** de API y requisitos (headers, rate limits).
- Manejar **idempotencia** de `POST` si la API lo ofrece (p. ej. `Idempotency-Key`).

---

## 10) Ejemplo integrador: miniâ€‘cliente con sesiÃ³n, auth y paginaciÃ³n

```python
'''
Cliente de ejemplo para una API paginada con token Bearer.
Variables de entorno:
  API_BASE=https://api.ejemplo.com/v1
  API_TOKEN=...
'''
import os, requests
from urllib.parse import urljoin
from urllib3.util.retry import Retry
from requests.adapters import HTTPAdapter

API_BASE = os.getenv("API_BASE", "https://jsonplaceholder.typicode.com/")
TOKEN = os.getenv("API_TOKEN", "fake-token")  # ejemplo

class APIClient:
    def __init__(self, base_url: str, token: str | None = None):
        self.base = base_url.rstrip("/") + "/"
        self.s = requests.Session()
        self.s.headers.update({"Accept": "application/json", "User-Agent": "TallerPython/1.0"})
        if token:
            self.s.headers.update({"Authorization": f"Bearer {token}"})
        retry = Retry(total=4, backoff_factor=0.5, status_forcelist=[429,500,502,503,504], allowed_methods=["GET","POST"])
        adapter = HTTPAdapter(max_retries=retry)
        self.s.mount("https://", adapter); self.s.mount("http://", adapter)

    def _url(self, path: str) -> str:
        return urljoin(self.base, path.lstrip("/"))

    def get_all(self, path: str, page_param="_page", limit_param="_limit", limit=100):
        page = 1
        accum = []
        while True:
            r = self.s.get(self._url(path), params={page_param: page, limit_param: limit}, timeout=(3, 15))
            r.raise_for_status()
            batch = r.json()
            if not batch:
                break
            accum.extend(batch)
            page += 1
        return accum

    def create(self, path: str, payload: dict):
        r = self.s.post(self._url(path), json=payload, timeout=(3, 15))
        r.raise_for_status()
        return r.json()

client = APIClient(API_BASE, TOKEN)

# Listar (paginado estilo jsonplaceholder)
posts = client.get_all("/posts", limit=50)
print("Posts:", len(posts))

# Crear
nuevo = client.create("/posts", {"title": "Hola API", "body": "contenido", "userId": 1})
print("Creado:", nuevo["id"] if "id" in nuevo else nuevo)
```

---
