# üß© Tema 1.2: Paradigmas y Tipos de Lenguajes

## üéØ Objetivo
Comprender los principales **paradigmas de programaci√≥n**, sus diferencias y c√≥mo los distintos lenguajes aplican estas ideas.
Adem√°s, reconocer otras clasificaciones b√°sicas: **nivel del lenguaje, tipo de ejecuci√≥n y capacidades t√©cnicas** (memoria, concurrencia, etc.).

---

## üß† ¬øQu√© es un paradigma de programaci√≥n?

Un **paradigma** es una forma de pensar y estructurar la soluci√≥n a un problema mediante c√≥digo.
Cada paradigma propone una **forma diferente de describir ‚Äúqu√© hace‚Äù y ‚Äúc√≥mo lo hace‚Äù un programa**.
Algunos lenguajes adoptan un solo paradigma, mientras que otros combinan varios (por ejemplo, **Python** soporta programaci√≥n imperativa, orientada a objetos y funcional).

> üí° **Ejemplo simple:**
> - En un lenguaje imperativo le decimos a la computadora *c√≥mo* hacerlo (paso a paso).
> - En uno declarativo le decimos *qu√©* queremos lograr, y el lenguaje decide c√≥mo hacerlo.

---

## üß© Clasificaci√≥n general de paradigmas

### üåç Taxonom√≠a general de paradigmas de programaci√≥n

```
                   ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
                   ‚îÇ   Paradigmas de Programaci√≥n  ‚îÇ
                   ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
                                ‚îÇ
        ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¥‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
        ‚îÇ                                                ‚îÇ
   Imperativos                                       Declarativos
 (c√≥mo hacer algo)                                (qu√© se quiere lograr)
        ‚îÇ                                                ‚îÇ
 ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê                           ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
 ‚îÇ      ‚îÇ           ‚îÇ                           ‚îÇ        ‚îÇ             ‚îÇ
Secuencial   Orientado a objetos   Procedural   Funcional   L√≥gico   Reactivo
 ‚îÇ               ‚îÇ                     ‚îÇ          ‚îÇ          ‚îÇ          ‚îÇ
C, C++        Java, C#, Python     Pascal       Haskell   Prolog     SQL, Excel
```

---

## üîß Principales paradigmas

| Paradigma | Enfoque | Descripci√≥n | Ejemplos de lenguajes |
|------------|----------|--------------|------------------------|
| **Imperativo** | ‚ÄúPaso a paso‚Äù | El programador indica c√≥mo lograr el resultado mediante instrucciones secuenciales que modifican el estado. | C, Fortran, Python (modo procedural) |
| **Orientado a Objetos (OOP)** | ‚ÄúTodo es un objeto‚Äù | Agrupa datos y comportamientos en entidades llamadas objetos. Favorece modularidad y reutilizaci√≥n. | Java, C#, Python, Ruby |
| **Funcional (Declarativo)** | ‚ÄúQu√© se calcula‚Äù | Se centra en funciones puras y evita el estado mutable. Ideal para procesamiento de datos y paralelismo. | Haskell, Lisp, F#, Scala, Python |
| **L√≥gico (Declarativo)** | ‚ÄúQu√© condiciones deben cumplirse‚Äù | Basado en reglas y relaciones l√≥gicas. El motor de inferencia busca soluciones. | Prolog |
| **Reactivo / Dataflow (Declarativo)** | ‚ÄúReacciona a cambios de datos o eventos‚Äù | Los valores y flujos se actualizan autom√°ticamente al cambiar dependencias. | Excel, RxJS, Elixir, Node.js Streams |

---

## üßÆ Tipado de lenguajes

| Tipo de tipado | Caracter√≠sticas | Ejemplos |
|----------------|-----------------|-----------|
| **Est√°tico** | El tipo de cada variable se define y verifica antes de ejecutar el programa. Previene errores en tiempo de compilaci√≥n. | C, C++, Java, Rust |
| **Din√°mico** | El tipo se determina en tiempo de ejecuci√≥n. Permite m√°s flexibilidad pero m√°s riesgo de errores. | Python, JavaScript, Ruby, PHP |

> üí¨ En Python pod√©s escribir:
> ```python
> x = 5
> x = "hola"
> ```
> En Java eso generar√≠a un error de tipo, ya que `x` fue declarado como entero.

---

## ‚öôÔ∏è Otros criterios de clasificaci√≥n de lenguajes

### 1. **Nivel de abstracci√≥n**

| Tipo de lenguaje | Descripci√≥n | Ejemplos |
|------------------|-------------|-----------|
| **Bajo nivel** | Cercano al hardware. Poca abstracci√≥n, control directo de memoria y CPU. | Ensamblador, C |
| **Alto nivel** | M√°s cercano al lenguaje humano. Oculta detalles del hardware. | Python, Java, Ruby |

> üìò *Los lenguajes de alto nivel facilitan la productividad, los de bajo nivel maximizan el rendimiento.*

---

### 2. **Tipo de ejecuci√≥n**

| Tipo | Descripci√≥n | Ejemplos |
|------|-------------|-----------|
| **Compilado** | El c√≥digo fuente se traduce completamente a lenguaje m√°quina antes de ejecutarse. R√°pido, pero requiere compilaci√≥n previa. | C, C++, Rust, Go |
| **Interpretado** | El c√≥digo se ejecuta l√≠nea por l√≠nea en tiempo real. M√°s lento, pero m√°s flexible y portable. | Python, JavaScript, PHP |
| **H√≠brido / Bytecode** | El c√≥digo se compila a una representaci√≥n intermedia (bytecode) y luego se interpreta o ejecuta en una m√°quina virtual. | Java, C#, Kotlin |

---

### 3. **Manejo de memoria**

| Tipo | Descripci√≥n | Ejemplos |
|------|-------------|-----------|
| **Manual** | El programador gestiona la memoria (asignaci√≥n/liberaci√≥n). | C, C++ |
| **Autom√°tico (GC)** | Un *garbage collector* libera memoria sin intervenci√≥n del programador. | Python, Java, Go |
| **Mixto / Controlado** | Permite control manual, pero con seguridad de tipos o punteros inteligentes. | Rust, Swift |

---

### 4. **Concurrencia y paralelismo**

| Caracter√≠stica | Descripci√≥n | Ejemplos |
|----------------|-------------|-----------|
| **Single-threaded** | Un solo flujo de ejecuci√≥n. Simplicidad, pero sin paralelismo real. | JavaScript (con async) |
| **Multithreading** | Permite ejecutar varios hilos en paralelo dentro del mismo proceso. | Java, C++, Python (limitado por GIL) |
| **Asincron√≠a / Concurrencia** | Permite manejar m√∫ltiples tareas ‚Äúa la vez‚Äù sin bloquear recursos, ideal para IO. | Node.js, Go, Rust (async/await), Python (asyncio) |

> üí° En Python, la concurrencia se logra principalmente con `asyncio`, pero el paralelismo real est√° limitado por el *Global Interpreter Lock (GIL)*.
> Lenguajes como Go o Rust manejan hilos y concurrencia nativamente.

---

## üìä Resumen comparativo general

| Criterio | Lenguajes Ejemplo | Ventajas | Limitaciones |
|-----------|------------------|-----------|---------------|
| **Imperativo** | C, Python | Control total del flujo | M√°s c√≥digo, m√°s propenso a errores |
| **OOP** | Java, C#, Python | Modularidad, reutilizaci√≥n | Puede ser m√°s complejo |
| **Funcional** | Haskell, Scala | Ideal para paralelismo | Menor adopci√≥n, curva te√≥rica |
| **L√≥gico** | Prolog | Resuelve problemas declarativos | Dif√≠cil de aplicar a todo tipo de programas |
| **Declarativo (mixto)** | SQL, Excel, React | Simplicidad en tareas espec√≠ficas | Menor control sobre el ‚Äúc√≥mo‚Äù |

---

## üìö Recursos recomendados

- [Introduction of Programming Paradigms ‚Äì GeeksforGeeks](https://www.geeksforgeeks.org/introduction-of-programming-paradigms/)
- [Compare Functional, Imperative & Object-Oriented Programming ‚Äì DigitalOcean](https://www.digitalocean.com/community/tutorials/functional-imperative-object-oriented-programming-comparison)
- [Programming Paradigm ‚Äì Wikipedia](https://en.wikipedia.org/wiki/Programming_paradigm)
- [Types of Programming Languages ‚Äì FreeCodeCamp](https://www.freecodecamp.org/news/types-of-programming-languages-explained/)
- [Concurrency vs Parallelism ‚Äì Medium](https://medium.com/@dmitrynozhenko/concurrency-vs-parallelism-8cdb44ab3f1a)
