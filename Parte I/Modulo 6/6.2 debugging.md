# üß≠ M√≥dulo 6: Pruebas y Control de Calidad de C√≥digo
## **Tema 6.2:** Debugging en VS Code / PyCharm y **logging**

---

### üéØ Objetivos de este tema
- Diferenciar **debugging** de **logging** y conocer cu√°ndo usar cada uno.
- Configurar y utilizar el depurador en **VS Code** y **PyCharm**.
- Conocer opciones de depuraci√≥n en **Jupyter Notebooks**, **Spyder** y **Marimo**.
- Implementar **logging** profesional: niveles, handlers, formato, rotaci√≥n y configuraci√≥n por diccionario.
- Aplicar buenas pr√°cticas para diagn√≥sticos efectivos y reproducibles.

---

## üß© Debugging vs Logging: ¬øcu√°ndo usar qu√©?
- **Debugging**: inspecci√≥n interactiva *en tiempo de ejecuci√≥n* (breakpoints, step in/out, watches). Ideal para casos puntuales o exploraci√≥n.
- **Logging**: registro **persistente** y cronol√≥gico del comportamiento. √ötil para reproducir incidentes en entornos donde no se puede depurar (producci√≥n, jobs batch, contenedores).

> Regla pr√°ctica: **depur√° para entender**, **logge√° para recordar y monitorear**.

---

## üß∞ Debugging en **VS Code**
### 1) Requisitos
- Extensi√≥n **Python** instalada.
- (Opcional) Extensi√≥n **Jupyter** para notebooks.

### 2) Breakpoints y ejecuci√≥n
1. Abr√≠ el archivo `.py`.
2. Click en el margen izquierdo para crear un **breakpoint**.
3. `Run and Debug` ‚Üí `Python: Current File` (o `F5`).

### 3) `launch.json` m√≠nimo
```jsonc
// .vscode/launch.json
{
  "version": "0.2.0",
  "configurations": [
    {
      "name": "Python: Archivo actual",
      "type": "python",
      "request": "launch",
      "program": "${file}",
      "console": "integratedTerminal",
      "justMyCode": true
    }
  ]
}
```

**Tips**  
- **Conditional breakpoint**: click derecho en el punto ‚Üí *Edit Breakpoint‚Ä¶* ‚Üí condici√≥n (`x > 10`) o *hit count*.
- **Watches / Variables**: panel *Run and Debug*.
- **Debug Console**: evalu√° expresiones en contexto.
- **Exception breakpoints**: activ√° *Break on raised exceptions* para cortar en el `raise`.

### 4) Depurar tests `pytest`
```jsonc
{
  "name": "Pytest: tests/",
  "type": "python",
  "request": "launch",
  "module": "pytest",
  "args": ["-q", "tests"],
  "console": "integratedTerminal",
  "justMyCode": true
}
```

### 5) Adjuntar a un proceso (remoto/contenedor)
En el proceso objetivo:
```python
# main.py
import debugpy
debugpy.listen(("0.0.0.0", 5678))
print("Esperando depurador‚Ä¶")
debugpy.wait_for_client()  # opcional
# ... resto del programa
```
En VS Code: **Python: Attach using Process Id / Host:Port** (5678).

---

## üß∞ Debugging en **PyCharm**
1. Configur√° **Run/Debug Configuration** (men√∫ superior).
2. Pon√© **breakpoints** y ejecut√° con el √≠cono de *Debug*.
3. Us√°:
   - **Watches** para expresiones.
   - **Evaluate Expression** (`Alt+F8`).
   - **Step Into/Over/Out**.
   - **Exception Breakpoints** (Break on *Any Exception* o solo *Uncaught*).
   - **Data Viewers** (listas, dicts, DataFrames).

**Consejo**: activ√° **Emulate terminal in output console** para programas que leen de `stdin`.

---

## üß™ Notebooks: **Jupyter**
- **Bot√≥n ‚ÄúDebug Cell‚Äù** (en VS Code + extensi√≥n Jupyter) permite depurar *por celda*.
- Modo *post-mortem* con magics:
  ```python
  %pdb on          # entra al depurador cuando ocurre una excepci√≥n
  %debug           # abre depurador en el √∫ltimo error
  %run -d script.py    # corre con depuraci√≥n
  breakpoint()     # corta la ejecuci√≥n aqu√≠ (Python 3.7+)
  ```
- **Variables**: en VS Code pod√©s verlas en el *Variable Explorer* del notebook.

---

## üêç IDE cient√≠fico: **Spyder**
- Depurador integrado (basado en `pdb`) con **breakpoints**, **step** y **Variable Explorer** muy c√≥modo para arrays y DataFrames.
- Atajos: *Debug file* (√≠cono del insecto con ‚Äúplay‚Äù), *Debug cell* si us√°s delimitadores `# %%`.
- **Perfilado**: men√∫ *Debug ‚Üí Profiler* para medir tiempo por funci√≥n.

---

## üß™ Notebooks reactivos: **Marimo**
- Marimo ejecuta celdas de forma reactiva. Estrategias de depuraci√≥n:
  1. **`breakpoint()`** dentro de una celda para abrir `pdb` en consola.
  2. **Adjuntar VS Code** con `debugpy` (igual que en ‚ÄúAdjuntar a un proceso‚Äù).
     ```python
     # en una celda marimo
     import debugpy; debugpy.listen(("0.0.0.0", 5678)); debugpy.wait_for_client()
     ```
  3. **Logging en celdas** (ver secci√≥n de logging).
- Buen truco: agreg√° **celdas de verificaci√≥n** que impriman shapes de datos, tipos y *checks* de invariantes.

---

## üìú **Logging** en Python (est√°ndar)
### Niveles
| Nivel | Uso t√≠pico |
|------|------------|
| `DEBUG` | Detalle para diagn√≥stico (no en producci√≥n por defecto). |
| `INFO` | Flujo normal (arranques, par√°metros, resultados resumidos). |
| `WARNING` | Algo inesperado pero el programa sigue. |
| `ERROR` | Fallo de una operaci√≥n; el programa puede continuar. |
| `CRITICAL` | Error grave; requiere atenci√≥n inmediata. |

### Inicio r√°pido
```python
import logging

logging.basicConfig(
    level=logging.INFO,
    format="%(asctime)s %(levelname)s [%(name)s] %(message)s"
)

logger = logging.getLogger(__name__)

def dividir(a, b):
    logger.debug("Entrando a dividir(%s, %s)", a, b)
    if b == 0:
        logger.error("Divisi√≥n por cero: a=%s, b=%s", a, b)
        raise ValueError("No se puede dividir por cero")
    res = a / b
    logger.info("Resultado: %s", res)
    return res
```

### Handlers y rotaci√≥n
```python
import logging
from logging.handlers import RotatingFileHandler, TimedRotatingFileHandler

logger = logging.getLogger("app")
logger.setLevel(logging.DEBUG)

# Consola
ch = logging.StreamHandler()
ch.setLevel(logging.INFO)

# Archivo rotativo por tama√±o
fh = RotatingFileHandler("app.log", maxBytes=1_000_000, backupCount=5)
fh.setLevel(logging.DEBUG)

# Rotaci√≥n diaria
tfh = TimedRotatingFileHandler("app_daily.log", when="midnight", backupCount=7)

fmt = logging.Formatter("%(asctime)s %(levelname)s [%(name)s] %(message)s")
for h in (ch, fh, tfh):
    h.setFormatter(fmt)
    logger.addHandler(h)

logger.info("Aplicaci√≥n iniciada")
```

### Configuraci√≥n por diccionario (`dictConfig`)
```python
import logging.config

LOGGING = {
  "version": 1,
  "disable_existing_loggers": False,
  "formatters": {
    "std": {"format": "%(asctime)s %(levelname)s [%(name)s] %(message)s"}
  },
  "handlers": {
    "console": {"class": "logging.StreamHandler", "level": "INFO", "formatter": "std"},
    "file": {
      "class": "logging.handlers.RotatingFileHandler",
      "level": "DEBUG",
      "formatter": "std",
      "filename": "app.log",
      "maxBytes": 1048576,
      "backupCount": 3
    }
  },
  "loggers": {
    "": {"handlers": ["console", "file"], "level": "DEBUG"}
  }
}

logging.config.dictConfig(LOGGING)
logger = logging.getLogger(__name__)
logger.info("Logging configurado")
```

### Logging estructurado (JSON) *(opcional)*
```python
# pip install python-json-logger
from pythonjsonlogger import jsonlogger
import logging, sys

logger = logging.getLogger("json")
logger.setLevel(logging.INFO)
handler = logging.StreamHandler(sys.stdout)
formatter = jsonlogger.JsonFormatter("%(asctime)s %(levelname)s %(name)s %(message)s")
handler.setFormatter(formatter)
logger.addHandler(handler)

logger.info("evento", extra={"etapa": "carga", "ok": True})
```

---

## üß™ Ejemplo integrado (debug + logging)
Estructura:
```
demo_debug_logging/
‚îÇ
‚îú‚îÄ‚îÄ app.py
‚îú‚îÄ‚îÄ core/
‚îÇ   ‚îî‚îÄ‚îÄ calc.py
‚îî‚îÄ‚îÄ logging.yaml  (opcional)
```

`core/calc.py`
```python
import logging
logger = logging.getLogger(__name__)

def promedio(xs):
    logger.debug("Calculando promedio de %d elementos", len(xs))
    if not xs:
        logger.warning("Lista vac√≠a, devolviendo None")
        return None
    s = sum(xs)
    r = s / len(xs)
    logger.info("promedio=%s", r)
    return r
```

`app.py`
```python
import logging, os
from core.calc import promedio

logging.basicConfig(level=os.getenv("LOGLEVEL", "INFO"))

def main():
    datos = [10, 12, 9, 8]
    p = promedio(datos)   # Pon√© un breakpoint aqu√≠
    print("Promedio:", p)

if __name__ == "__main__":
    main()
```

**Debugging**: pon√© breakpoints en `promedio` y en `main()`; inspeccion√° `datos` y `p`.
**Logging**: cambi√° `LOGLEVEL=DEBUG` y observ√° el detalle adicional.

---

## ‚úÖ Buenas pr√°cticas
- **No abuses del debugger** en producci√≥n; prefer√≠ **logs** con niveles adecuados.
- Cre√° **loggers por m√≥dulo**: `logging.getLogger(__name__)`.
- **No loggees datos sensibles** (tokens, contrase√±as, DNI completos).
- Us√° **IDs de correlaci√≥n** en flujos distribuidos (p. ej., `request_id` en `extra=`).
- Para notebooks, separ√° **celdas ‚Äúde exploraci√≥n‚Äù** y **celdas ‚Äúde pipeline‚Äù**; registr√° par√°metros clave con `INFO`.
- En contenedores, prefer√≠ **stdout** y recolecci√≥n por el *runtime* (Docker/K8s).
- Activ√° **exception breakpoints** cuando investigues errores intermitentes.
- Guard√° **config de depuraci√≥n** (`launch.json` / Run Config) en el repo cuando sea √∫til para el equipo.

---

## üßæ Resumen
| Tema | Clave |
|---|---|
| VS Code | `launch.json`, breakpoints condicionales, attach con `debugpy`, debug de `pytest`. |
| PyCharm | Run/Debug Configs, *Evaluate Expression*, *Exception Breakpoints*. |
| Jupyter | `%pdb on`, `%debug`, `breakpoint()`, *Debug Cell* en VS Code. |
| Spyder | Depurador integrado + Variable Explorer. |
| Marimo | `breakpoint()`, adjuntar `debugpy`, celdas de verificaci√≥n. |
| Logging | `basicConfig`, handlers (rotaci√≥n), `dictConfig`, JSON logs, buenas pr√°cticas. |

---

## üîó Recursos
- VS Code / debugpy:
  - Run & Debug (VS Code - Python): https://code.visualstudio.com/docs/python/debugging
  - Extensi√≥n Python (VS Code Marketplace): https://marketplace.visualstudio.com/items?itemName=ms-python.python
  - debugpy (attach / remote debugging): https://github.com/microsoft/debugpy
- PyCharm:
  - Debugging in PyCharm (JetBrains docs): https://www.jetbrains.com/help/pycharm/debugging-code.html
- Jupyter / IPython magics:
  - IPython magics reference (incluye `%pdb`, `%debug`, `%run`): https://ipython.readthedocs.io/en/stable/interactive/magics.html
  - Debugging Jupyter notebooks in VS Code: https://code.visualstudio.com/docs/python/jupyter-support#_debugging
- Python logging (docs oficiales):
  - Logging HOWTO (Python docs): https://docs.python.org/3/howto/logging.html
  - logging.handlers (RotatingFileHandler, TimedRotatingFileHandler): https://docs.python.org/3/library/logging.handlers.html
- JSON logs / librer√≠as:
  - python-json-logger (PyPI): https://pypi.org/project/python-json-logger/
  - python-json-logger (GitHub): https://github.com/madzak/python-json-logger

Si quer√©s, puedo a√±adir enlaces adicionales (ej.: ejemplos de `launch.json` para pytest, plantillas de `logging.yaml` o gu√≠as para configurar `debugpy` en contenedores). 

---

> **Conclusi√≥n**: combinando **debuggers** para analizar situaciones puntuales y **logging** para trazabilidad continua, obten√©s diagn√≥sticos r√°pidos y sistemas observables y mantenibles.
