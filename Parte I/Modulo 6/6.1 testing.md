# üß™ M√≥dulo 6: Pruebas y Control de Calidad de C√≥digo
## **Tema 6.1:** Pruebas con `pytest` (fixtures, parametrizaci√≥n, coverage)

---

### üéØ Objetivos de este tema

- Comprender la importancia de las pruebas autom√°ticas en el desarrollo de software.
- Aprender a crear pruebas unitarias con **pytest**.
- Utilizar **fixtures** para inicializar contextos comunes.
- Emplear **parametrizaci√≥n** para automatizar m√∫ltiples casos de prueba.
- Medir la **cobertura de c√≥digo** (*coverage*) para evaluar la calidad de las pruebas.

---

## üß© Introducci√≥n a las pruebas

Las **pruebas autom√°ticas** permiten verificar que el c√≥digo se comporte como se espera sin necesidad de hacerlo manualmente cada vez que se modifica algo.

En proyectos grandes o colaborativos, esto es fundamental para:
- Asegurar **consistencia y confiabilidad** del software.
- Detectar errores temprano (**regresiones**).
- Facilitar la **refactorizaci√≥n** del c√≥digo.
- Mejorar la **documentaci√≥n funcional** del comportamiento esperado.

### Tipos de pruebas m√°s comunes

| Tipo de prueba | Descripci√≥n breve | Ejemplo |
|----------------|------------------|----------|
| **Unitarias** | Verifican una funci√≥n o m√≥dulo espec√≠fico. | `test_sumar()` |
| **Integraci√≥n** | Verifican la interacci√≥n entre varios m√≥dulos. | `test_api_y_base_de_datos()` |
| **Funcionales / End-to-End** | Eval√∫an el comportamiento general del sistema. | `test_login_usuario()` |

---

## ‚öôÔ∏è Instalaci√≥n de `pytest`

`pytest` es uno de los frameworks de testing m√°s populares en Python.

```bash
pip install pytest
```

Para ejecutar pruebas en un proyecto:
```bash
pytest
```

Por defecto, `pytest` buscar√° archivos llamados:
- `test_*.py`
- `*_test.py`

---

## üß± Estructura b√°sica de una prueba

```python
# test_math.py
def sumar(a, b):
    return a + b

def test_sumar():
    assert sumar(2, 3) == 5
    assert sumar(-1, 1) == 0
```

Para ejecutar:
```bash
pytest test_math.py
```

### üìã Salida esperada

```
============================= test session starts =============================
collected 1 item

test_math.py .                                                       [100%]

============================== 1 passed in 0.01s =============================
```

---

## üîß Fixtures: Inicializaci√≥n y reutilizaci√≥n de datos

Las **fixtures** son funciones que preparan datos o entornos comunes que pueden ser reutilizados por m√∫ltiples pruebas.

```python
import pytest

@pytest.fixture
def sample_data():
    return [1, 2, 3, 4, 5]

def test_suma_total(sample_data):
    assert sum(sample_data) == 15
```

Ventajas:
- Evitan repetici√≥n de c√≥digo.
- Permiten preparar entornos complejos (bases de datos, archivos temporales, etc.).
- Se pueden combinar y encadenar.

---

## üéõÔ∏è Parametrizaci√≥n: m√∫ltiples casos de prueba

Permite ejecutar la misma prueba con distintos valores de entrada.

```python
import pytest

@pytest.mark.parametrize("a,b,resultado", [
    (2, 3, 5),
    (-1, 1, 0),
    (10, -5, 5)
])
def test_sumar_parametrizado(a, b, resultado):
    assert a + b == resultado
```

Salida:
```
test_sumar_parametrizado[2-3-5] PASSED
test_sumar_parametrizado[-1-1-0] PASSED
test_sumar_parametrizado[10--5-5] PASSED
```

---

## üìä Medici√≥n de cobertura de c√≥digo (`pytest-cov`)

La **cobertura de c√≥digo** indica qu√© porcentaje del c√≥digo ha sido ejecutado durante las pruebas.

Instalaci√≥n:
```bash
pip install pytest-cov
```

Ejecuci√≥n:
```bash
pytest --cov=nombre_paquete tests/
```

Ejemplo de salida:
```
---------- coverage: platform linux, python 3.11 ----------
Name                     Stmts   Miss  Cover
--------------------------------------------
app/math_utils.py            8      0   100%
app/strings.py               5      1    80%
--------------------------------------------
TOTAL                       13      1    92%
```

Esto permite detectar partes del c√≥digo que no est√°n siendo probadas.

---

## üß† Buenas pr√°cticas

- Nombrar las funciones de prueba con prefijo `test_`.
- Incluir **casos l√≠mite** y **errores esperados**.
- Mantener las pruebas **peque√±as e independientes**.
- Ejecutarlas con frecuencia (integraci√≥n continua).
- Evitar dependencias externas innecesarias.

---

## üß∞ Ejemplo completo

Estructura de proyecto:

```
mi_proyecto/
‚îÇ
‚îú‚îÄ‚îÄ app/
‚îÇ   ‚îî‚îÄ‚îÄ operaciones.py
‚îÇ
‚îî‚îÄ‚îÄ tests/
    ‚îî‚îÄ‚îÄ test_operaciones.py
```

### üìÅ `app/operaciones.py`

```python
def dividir(a, b):
    if b == 0:
        raise ValueError("No se puede dividir por cero")
    return a / b
```

### üìÅ `tests/test_operaciones.py`

```python
import pytest
from app.operaciones import dividir

@pytest.mark.parametrize("a,b,resultado", [
    (10, 2, 5),
    (9, 3, 3),
    (5, -1, -5)
])
def test_dividir(a, b, resultado):
    assert dividir(a, b) == resultado

def test_dividir_por_cero():
    with pytest.raises(ValueError):
        dividir(10, 0)
```

Ejecuci√≥n con cobertura:
```bash
pytest --cov=app
```

---

## üßæ Resumen

| Concepto | Descripci√≥n | Ejemplo |
|-----------|-------------|----------|
| **pytest** | Framework de testing liviano y potente. | `pytest test_archivo.py` |
| **fixture** | Inicializa datos comunes para varias pruebas. | `@pytest.fixture` |
| **parametrize** | Ejecuta la misma prueba con m√∫ltiples entradas. | `@pytest.mark.parametrize()` |
| **coverage** | Mide el porcentaje de c√≥digo probado. | `pytest --cov=modulo` |

---

## üîó Recursos √∫tiles

- Documentaci√≥n oficial de pytest: https://docs.pytest.org/
- pytest-cov (coverage): https://pypi.org/project/pytest-cov/
- Gu√≠a de buenas pr√°cticas de testing en Python (Real Python): https://realpython.com/pytest-python-testing/
- Testing en proyectos con estructura modular: https://docs.python-guide.org/writing/tests/

---

> üß© **Conclusi√≥n:**
> Las pruebas autom√°ticas con `pytest` son una herramienta esencial para cualquier proyecto profesional. Permiten detectar errores r√°pidamente, mantener la calidad del c√≥digo y ganar confianza al realizar cambios o refactorizaciones.
