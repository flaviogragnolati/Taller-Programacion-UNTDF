# ğŸ MÃ³dulo 3: Fundamentos de Python

## **Tema 3.6 â€“ PublicaciÃ³n de paquetes y mÃ³dulos**

---

## ğŸ¯ Objetivo

Comprender los **conceptos bÃ¡sicos de publicaciÃ³n de paquetes y mÃ³dulos en Python**, sus **usos**, y las **diferencias** entre paquetes de **uso pÃºblico (terceros)** y paquetes de **uso interno o corporativo**.

El objetivo es conocer los pasos y herramientas que permiten convertir cÃ³digo en un paquete reutilizable, compartible y mantenible.

---

## ğŸ§­ IntroducciÃ³n

Python organiza su cÃ³digo en **mÃ³dulos** y **paquetes**. Un mÃ³dulo es un Ãºnico archivo `.py`, mientras que un paquete es un **conjunto estructurado** de mÃ³dulos con un archivo `__init__.py` que indica que se trata de un paquete.

Publicar un paquete significa **empaquetar y distribuir** un conjunto de mÃ³dulos para que puedan ser **instalados fÃ¡cilmente** mediante herramientas como `pip`, tanto por otros usuarios como por otros proyectos internos.

---

## ğŸ“¦ 1) Â¿Por quÃ© publicar paquetes?

Publicar un paquete tiene mÃºltiples propÃ³sitos:

* âœ… **ReutilizaciÃ³n:** evita duplicar cÃ³digo en diferentes proyectos.
* ğŸ§© **Mantenibilidad:** facilita actualizaciones y control de versiones.
* ğŸš€ **ColaboraciÃ³n:** permite compartir librerÃ­as entre equipos o con la comunidad.
* ğŸ” **DistribuciÃ³n controlada:** posibilita tener versiones internas privadas o paquetes pÃºblicos abiertos al mundo.

---

## ğŸ§© 2) MÃ³dulos vs Paquetes

| Concepto       | DescripciÃ³n                                                         | Ejemplo                                                      |
| -------------- | ------------------------------------------------------------------- | ------------------------------------------------------------ |
| **MÃ³dulo**     | Archivo `.py` que agrupa funciones, clases o variables relacionadas | `utilidades.py`                                              |
| **Paquete**    | Carpeta con varios mÃ³dulos y un `__init__.py`                       | `mi_paquete/` â†’ contiene `__init__.py`, `mod1.py`, `mod2.py` |
| **Subpaquete** | Carpeta dentro de un paquete que organiza funcionalidades           | `mi_paquete/red/cliente.py`                                  |

**Estructura mÃ­nima de un paquete:**

```plaintext
mi_paquete/
â”œâ”€â”€ __init__.py
â”œâ”€â”€ operaciones.py
â””â”€â”€ datos.py
```

El archivo `__init__.py` puede estar vacÃ­o o contener cÃ³digo de inicializaciÃ³n del paquete.

---

## ğŸ—ï¸ 3) Estructura tÃ­pica para empaquetar un proyecto

```plaintext
mi_paquete/
â”œâ”€â”€ src/mi_paquete/__init__.py
â”œâ”€â”€ pyproject.toml
â”œâ”€â”€ README.md
â”œâ”€â”€ LICENSE
â””â”€â”€ tests/
```

### Archivos clave

* **`pyproject.toml`** â†’ define metadatos y configuraciÃ³n del paquete (nombre, versiÃ³n, dependencias, herramientas de build como `setuptools` o `hatchling`).
* **`README.md`** â†’ descripciÃ³n del proyecto.
* **`LICENSE`** â†’ tipo de licencia de uso.
* **`tests/`** â†’ pruebas automÃ¡ticas.

Ejemplo de `pyproject.toml` mÃ­nimo:

```toml
[project]
name = "mi-paquete"
version = "0.1.0"
description = "Utilidades comunes para proyectos internos"
authors = [ { name="Equipo Desarrollo", email="dev@empresa.com" } ]
readme = "README.md"
requires-python = ">=3.10"
```

---

## ğŸŒ 4) Tipos de publicaciÃ³n

### a) **Paquetes pÃºblicos (para terceros)**

Se publican en el **Python Package Index (PyPI)**, donde cualquier usuario puede instalarlos mediante:

```bash
pip install nombre-paquete
```

**Casos de uso:**

* LibrerÃ­as de propÃ³sito general (ej. `requests`, `numpy`, `pandas`).
* Herramientas que aportan a la comunidad.

**Ventajas:**

* Visibilidad y contribuciÃ³n abierta.
* Facilita la adopciÃ³n y retroalimentaciÃ³n.

**DesafÃ­os:**

* Mantenimiento y compatibilidad con mÃºltiples entornos.
* DocumentaciÃ³n y licenciamiento pÃºblico.

---

### b) **Paquetes internos o privados**

Destinados al **uso interno** de una empresa u organizaciÃ³n. Pueden ser compartidos:

* Dentro de la misma red (repositorio privado de PyPI o `devpi`).
* En sistemas de control de versiones (`GitLab`, `GitHub Packages`).
* En forma local (`pip install ./mi_paquete`).

**Casos de uso:**

* MÃ³dulos compartidos entre microservicios.
* LibrerÃ­as internas de logging, seguridad, o acceso a base de datos.
* Herramientas internas de anÃ¡lisis o automatizaciÃ³n.

**Ventajas:**

* Control de acceso y versiones internas.
* IntegraciÃ³n directa con CI/CD.
* Permite mantener coherencia en los proyectos de la organizaciÃ³n.

---

## âš™ï¸ 5) Herramientas comunes para empaquetado y publicaciÃ³n

| Herramienta               | FunciÃ³n principal                                            |
| ------------------------- | ------------------------------------------------------------ |
| **setuptools**            | Empaquetar y distribuir cÃ³digo (histÃ³ricamente la mÃ¡s usada) |
| **hatch / flit / poetry** | Alternativas modernas con gestiÃ³n de dependencias integrada  |
| **twine**                 | Subir paquetes a PyPI de forma segura                        |
| **pip**                   | Instalar y administrar paquetes                              |
| **build**                 | Compilar el paquete localmente (`python -m build`)           |

**Ejemplo de publicaciÃ³n a PyPI:**

```bash
pip install build twine
python -m build
python -m twine upload dist/*
```

---

## ğŸ§  6) Buenas prÃ¡cticas

* Usar **nombres claros y Ãºnicos** para los paquetes.
* Incluir **README** y **LICENSE** siempre.
* Mantener una **versiÃ³n semÃ¡ntica (SemVer)** â†’ `MAJOR.MINOR.PATCH`.
* Crear **entornos virtuales** (`venv`, `uv`, `conda`) para aislar dependencias.
* Documentar dependencias en `pyproject.toml` o `requirements.txt`.

---

## ğŸ§© 7) CuÃ¡ndo publicar un paquete

| SituaciÃ³n                                           | RecomendaciÃ³n                          |
| --------------------------------------------------- | -------------------------------------- |
| Varias aplicaciones repiten el mismo cÃ³digo         | Crear un paquete interno y compartirlo |
| Funcionalidad genÃ©rica que podrÃ­a usar la comunidad | Publicar en PyPI                       |
| CÃ³digo muy especÃ­fico de un solo proyecto           | Mantener como mÃ³dulo local             |

---

---

## ğŸ“‚ 8) OrganizaciÃ³n de proyectos locales grandes y complejos

Cuando un proyecto crece mÃ¡s allÃ¡ de simples scripts o notebooks, pero **no necesariamente serÃ¡ un paquete publicable**, es fundamental establecer una estructura sÃ³lida que facilite:

* ğŸ”„ **Mantenibilidad a largo plazo**
* ğŸ‘¥ **ColaboraciÃ³n entre equipos**
* ğŸ§ª **Testing y calidad del cÃ³digo**
* ğŸš€ **Despliegue y escalabilidad**
* ğŸ“¦ **GestiÃ³n de dependencias reproducible**

### ğŸ¯ Â¿CuÃ¡ndo necesitas una estructura de proyecto compleja?

| Indicador                                       | AcciÃ³n recomendada                     |
| ----------------------------------------------- | -------------------------------------- |
| MÃºltiples mÃ³dulos interdependientes             | Estructura de paquete local            |
| Varios colaboradores trabajando simultÃ¡neamente | Control de versiones + estructura clara |
| Tests, linters, formatters, CI/CD               | ConfiguraciÃ³n profesional del proyecto |
| Diferentes entornos (dev, test, prod)           | GestiÃ³n de dependencias aislada        |
| Configuraciones complejas                       | Archivos de configuraciÃ³n separados    |

### ğŸ—ï¸ Estructura recomendada para proyectos grandes

```plaintext
mi_proyecto/
â”œâ”€â”€ src/
â”‚   â””â”€â”€ mi_proyecto/           # CÃ³digo fuente principal
â”‚       â”œâ”€â”€ __init__.py
â”‚       â”œâ”€â”€ core/              # LÃ³gica de negocio central
â”‚       â”‚   â”œâ”€â”€ __init__.py
â”‚       â”‚   â”œâ”€â”€ models.py
â”‚       â”‚   â””â”€â”€ services.py
â”‚       â”œâ”€â”€ api/               # Endpoints o interfaces
â”‚       â”‚   â”œâ”€â”€ __init__.py
â”‚       â”‚   â””â”€â”€ routes.py
â”‚       â”œâ”€â”€ utils/             # Utilidades compartidas
â”‚       â”‚   â”œâ”€â”€ __init__.py
â”‚       â”‚   â”œâ”€â”€ helpers.py
â”‚       â”‚   â””â”€â”€ validators.py
â”‚       â””â”€â”€ config/            # Configuraciones
â”‚           â”œâ”€â”€ __init__.py
â”‚           â””â”€â”€ settings.py
â”œâ”€â”€ tests/                     # Tests organizados como el src/
â”‚   â”œâ”€â”€ __init__.py
â”‚   â”œâ”€â”€ test_core/
â”‚   â”œâ”€â”€ test_api/
â”‚   â””â”€â”€ conftest.py            # Fixtures compartidos
â”œâ”€â”€ docs/                      # DocumentaciÃ³n
â”‚   â””â”€â”€ README.md
â”œâ”€â”€ scripts/                   # Scripts de automatizaciÃ³n
â”‚   â”œâ”€â”€ setup.sh
â”‚   â””â”€â”€ deploy.py
â”œâ”€â”€ data/                      # Datos (si aplica)
â”‚   â”œâ”€â”€ raw/
â”‚   â””â”€â”€ processed/
â”œâ”€â”€ notebooks/                 # Notebooks exploratorios
â”‚   â””â”€â”€ exploracion.ipynb
â”œâ”€â”€ .env.example               # Template de variables de entorno
â”œâ”€â”€ .gitignore
â”œâ”€â”€ pyproject.toml            # ConfiguraciÃ³n del proyecto
â”œâ”€â”€ README.md
â””â”€â”€ LICENSE
```

### ğŸ“‹ Principios de organizaciÃ³n

1. **SeparaciÃ³n de concerns**: Cada mÃ³dulo tiene una responsabilidad clara
2. **Src layout**: El cÃ³digo fuente va en `src/` para evitar importaciones accidentales
3. **Tests paralelos**: Estructura de tests que refleja la del cÃ³digo fuente
4. **ConfiguraciÃ³n centralizada**: Un solo lugar para metadatos y dependencias
5. **DocumentaciÃ³n cercana al cÃ³digo**: README por mÃ³dulo cuando es necesario

### ğŸ”— RelaciÃ³n con buenas prÃ¡cticas previas

Esta estructura implementa las buenas prÃ¡cticas vistas anteriormente:

* âœ… **Naming conventions**: Nombres descriptivos en mÃ³dulos y paquetes
* âœ… **DRY (Don't Repeat Yourself)**: CÃ³digo reutilizable en `utils/`
* âœ… **Modularidad**: SeparaciÃ³n lÃ³gica en `core/`, `api/`, `utils/`
* âœ… **Type hints**: Facilita el uso de mypy con estructura clara
* âœ… **Testing**: Estructura dedicada para tests completos
* âœ… **Documentation**: Espacio para documentaciÃ³n tÃ©cnica y de usuario

---

## ğŸ› ï¸ 9) ConfiguraciÃ³n prÃ¡ctica con Poetry

**Poetry** es una herramienta moderna que gestiona dependencias, entornos virtuales y empaquetado en un solo lugar.

### ğŸ“¥ InstalaciÃ³n de Poetry

```bash
# MÃ©todo recomendado (instalador oficial)
curl -sSL https://install.python-poetry.org | python3 -

# O usando pipx (recomendado si ya lo tienes)
pipx install poetry

# Verificar instalaciÃ³n
poetry --version
```

### ğŸš€ Ejemplo paso a paso: Crear proyecto con Poetry

#### Paso 1: Inicializar el proyecto

```bash
# Crear directorio del proyecto
mkdir mi_proyecto_analytics
cd mi_proyecto_analytics

# Inicializar Poetry (modo interactivo)
poetry init

# O directamente con parÃ¡metros
poetry new mi_proyecto_analytics --name analytics --src
```

El comando `poetry new` con `--src` crea automÃ¡ticamente la estructura recomendada:

```plaintext
mi_proyecto_analytics/
â”œâ”€â”€ src/
â”‚   â””â”€â”€ analytics/
â”‚       â””â”€â”€ __init__.py
â”œâ”€â”€ tests/
â”‚   â””â”€â”€ __init__.py
â”œâ”€â”€ pyproject.toml
â””â”€â”€ README.md
```

#### Paso 2: Configurar `pyproject.toml`

Poetry genera un `pyproject.toml` base. PersonalizÃ©moslo:

```toml
[tool.poetry]
name = "analytics"
version = "0.1.0"
description = "Sistema de anÃ¡lisis de datos para reportes internos"
authors = ["Tu Nombre <tu.email@empresa.com>"]
readme = "README.md"
packages = [{include = "analytics", from = "src"}]

[tool.poetry.dependencies]
python = "^3.10"
pandas = "^2.0.0"
numpy = "^1.24.0"
requests = "^2.31.0"

[tool.poetry.group.dev.dependencies]
pytest = "^7.4.0"
pytest-cov = "^4.1.0"
black = "^23.7.0"
ruff = "^0.0.280"
mypy = "^1.4.0"

[tool.poetry.group.docs.dependencies]
mkdocs = "^1.5.0"
mkdocs-material = "^9.1.0"

[build-system]
requires = ["poetry-core"]
build-backend = "poetry.core.masonry.api"

[tool.black]
line-length = 88
target-version = ['py310']

[tool.ruff]
line-length = 88
select = ["E", "F", "I", "N", "W"]

[tool.mypy]
python_version = "3.10"
strict = true
```

#### Paso 3: Instalar dependencias

```bash
# Instalar todas las dependencias definidas
poetry install

# Solo dependencias de producciÃ³n (sin dev)
poetry install --only main

# Agregar nueva dependencia
poetry add fastapi

# Agregar dependencia de desarrollo
poetry add --group dev ipython
```

#### Paso 4: Crear estructura del proyecto

```bash
# Crear estructura de mÃ³dulos
mkdir -p src/analytics/{core,api,utils,config}
touch src/analytics/{core,api,utils,config}/__init__.py

# Crear archivos de cÃ³digo
cat > src/analytics/core/models.py << 'EOF'
"""Modelos de datos del sistema."""
from dataclasses import dataclass
from datetime import datetime


@dataclass
class Report:
    """Modelo para reportes de anÃ¡lisis."""
    
    id: str
    title: str
    created_at: datetime
    data: dict
    
    def summary(self) -> str:
        """Retorna un resumen del reporte."""
        return f"Report {self.id}: {self.title} ({self.created_at})"
EOF

cat > src/analytics/utils/helpers.py << 'EOF'
"""Funciones auxiliares para el proyecto."""
from typing import Any


def normalize_data(data: dict[str, Any]) -> dict[str, Any]:
    """Normaliza datos eliminando valores nulos."""
    return {k: v for k, v in data.items() if v is not None}


def format_currency(amount: float) -> str:
    """Formatea un monto como moneda."""
    return f"${amount:,.2f}"
EOF

cat > src/analytics/config/settings.py << 'EOF'
"""ConfiguraciÃ³n de la aplicaciÃ³n."""
import os
from pathlib import Path


class Settings:
    """ConfiguraciÃ³n central de la aplicaciÃ³n."""
    
    BASE_DIR = Path(__file__).parent.parent.parent.parent
    DATA_DIR = BASE_DIR / "data"
    
    # Variables de entorno
    DEBUG = os.getenv("DEBUG", "False") == "True"
    API_KEY = os.getenv("API_KEY", "")
    DATABASE_URL = os.getenv("DATABASE_URL", "sqlite:///./analytics.db")
    

settings = Settings()
EOF
```

#### Paso 5: Crear tests

```bash
# Crear estructura de tests
mkdir -p tests/{test_core,test_utils}
touch tests/{test_core,test_utils}/__init__.py

cat > tests/test_core/test_models.py << 'EOF'
"""Tests para los modelos."""
from datetime import datetime
from analytics.core.models import Report


def test_report_creation():
    """Test de creaciÃ³n de reporte."""
    report = Report(
        id="R001",
        title="Ventas Q1",
        created_at=datetime.now(),
        data={"total": 1000}
    )
    assert report.id == "R001"
    assert report.title == "Ventas Q1"


def test_report_summary():
    """Test del mÃ©todo summary."""
    report = Report(
        id="R002",
        title="Test Report",
        created_at=datetime(2024, 1, 1),
        data={}
    )
    summary = report.summary()
    assert "R002" in summary
    assert "Test Report" in summary
EOF

cat > tests/test_utils/test_helpers.py << 'EOF'
"""Tests para funciones auxiliares."""
from analytics.utils.helpers import normalize_data, format_currency


def test_normalize_data():
    """Test de normalizaciÃ³n de datos."""
    data = {"a": 1, "b": None, "c": 3}
    result = normalize_data(data)
    assert result == {"a": 1, "c": 3}
    assert "b" not in result


def test_format_currency():
    """Test de formateo de moneda."""
    assert format_currency(1000) == "$1,000.00"
    assert format_currency(1234.56) == "$1,234.56"
EOF
```

#### Paso 6: Ejecutar el proyecto

```bash
# Activar el entorno virtual de Poetry
poetry shell

# Ejecutar tests
poetry run pytest

# Con cobertura
poetry run pytest --cov=analytics --cov-report=html

# Formatear cÃ³digo
poetry run black src/ tests/

# Linting
poetry run ruff check src/ tests/

# Type checking
poetry run mypy src/
```

#### Paso 7: Usar el cÃ³digo

```bash
# Desde un script Python
poetry run python script.py

# O dentro del shell de Poetry
poetry shell
python script.py
```

Ejemplo de `script.py`:

```python
from analytics.core.models import Report
from analytics.utils.helpers import format_currency
from datetime import datetime

# Crear reporte
report = Report(
    id="R001",
    title="AnÃ¡lisis de ventas",
    created_at=datetime.now(),
    data={"total_sales": 15000.50}
)

print(report.summary())
print(f"Total: {format_currency(report.data['total_sales'])}")
```

### ğŸ“¦ Exportar/compartir el entorno

```bash
# Generar requirements.txt para compatibilidad
poetry export -f requirements.txt --output requirements.txt --without-hashes

# Generar lock file para reproducibilidad exacta
poetry lock

# Actualizar dependencias
poetry update

# Mostrar dependencias instaladas
poetry show --tree
```

---

## âš¡ 10) ConfiguraciÃ³n prÃ¡ctica con UV

**UV** es una herramienta extremadamente rÃ¡pida escrita en Rust para gestiÃ³n de paquetes y entornos Python.

### ğŸ“¥ InstalaciÃ³n de UV

```bash
# En Linux/macOS
curl -LsSf https://astral.sh/uv/install.sh | sh

# En Windows (PowerShell)
powershell -c "irm https://astral.sh/uv/install.ps1 | iex"

# O usando pip
pip install uv

# Verificar instalaciÃ³n
uv --version
```

### ğŸš€ Ejemplo paso a paso: Crear proyecto con UV

#### Paso 1: Inicializar el proyecto

```bash
# Crear directorio y estructura base
mkdir mi_proyecto_api
cd mi_proyecto_api

# Inicializar proyecto con UV
uv init

# O crear un nuevo proyecto con estructura
uv init --name api_service --lib
```

UV crea una estructura bÃ¡sica:

```plaintext
mi_proyecto_api/
â”œâ”€â”€ pyproject.toml
â”œâ”€â”€ README.md
â””â”€â”€ src/
    â””â”€â”€ api_service/
        â””â”€â”€ __init__.py
```

#### Paso 2: Configurar `pyproject.toml`

```toml
[project]
name = "api-service"
version = "0.1.0"
description = "Servicio API para gestiÃ³n de recursos"
authors = [
    {name = "Tu Nombre", email = "tu.email@empresa.com"}
]
readme = "README.md"
requires-python = ">=3.10"
dependencies = [
    "fastapi>=0.104.0",
    "uvicorn[standard]>=0.24.0",
    "pydantic>=2.4.0",
    "sqlalchemy>=2.0.0",
    "httpx>=0.25.0",
]

[project.optional-dependencies]
dev = [
    "pytest>=7.4.0",
    "pytest-asyncio>=0.21.0",
    "pytest-cov>=4.1.0",
    "ruff>=0.1.0",
    "black>=23.10.0",
    "mypy>=1.6.0",
]

[build-system]
requires = ["hatchling"]
build-backend = "hatchling.build"

[tool.ruff]
line-length = 100
target-version = "py310"

[tool.black]
line-length = 100
target-version = ["py310"]

[tool.pytest.ini_options]
testpaths = ["tests"]
python_files = ["test_*.py"]
python_functions = ["test_*"]
```

#### Paso 3: Crear entorno e instalar dependencias

```bash
# Crear entorno virtual y sincronizar dependencias
uv sync

# Instalar dependencias de desarrollo tambiÃ©n
uv sync --all-extras

# Agregar una nueva dependencia
uv add redis

# Agregar dependencia de desarrollo
uv add --dev ipython

# Eliminar dependencia
uv remove redis
```

#### Paso 4: Crear estructura del proyecto

```bash
# Crear estructura de mÃ³dulos
mkdir -p src/api_service/{routes,models,services,database}
touch src/api_service/{routes,models,services,database}/__init__.py

# Crear archivos de cÃ³digo
cat > src/api_service/models/schemas.py << 'EOF'
"""Esquemas Pydantic para validaciÃ³n."""
from datetime import datetime
from pydantic import BaseModel, Field, ConfigDict


class ResourceBase(BaseModel):
    """Esquema base para recursos."""
    
    name: str = Field(..., min_length=1, max_length=100)
    description: str | None = None
    active: bool = True


class ResourceCreate(ResourceBase):
    """Esquema para creaciÃ³n de recursos."""
    pass


class Resource(ResourceBase):
    """Esquema completo de recurso."""
    
    id: int
    created_at: datetime
    updated_at: datetime
    
    model_config = ConfigDict(from_attributes=True)
EOF

cat > src/api_service/services/resource_service.py << 'EOF'
"""LÃ³gica de negocio para recursos."""
from typing import List
from ..models.schemas import Resource, ResourceCreate


class ResourceService:
    """Servicio para gestiÃ³n de recursos."""
    
    def __init__(self):
        self._resources: dict[int, Resource] = {}
        self._next_id = 1
    
    def create_resource(self, data: ResourceCreate) -> Resource:
        """Crea un nuevo recurso."""
        from datetime import datetime
        
        resource = Resource(
            id=self._next_id,
            **data.model_dump(),
            created_at=datetime.now(),
            updated_at=datetime.now()
        )
        self._resources[self._next_id] = resource
        self._next_id += 1
        return resource
    
    def get_all_resources(self) -> List[Resource]:
        """Obtiene todos los recursos."""
        return list(self._resources.values())
    
    def get_resource(self, resource_id: int) -> Resource | None:
        """Obtiene un recurso por ID."""
        return self._resources.get(resource_id)
EOF

cat > src/api_service/routes/resources.py << 'EOF'
"""Rutas API para recursos."""
from fastapi import APIRouter, HTTPException, status
from typing import List

from ..models.schemas import Resource, ResourceCreate
from ..services.resource_service import ResourceService


router = APIRouter(prefix="/resources", tags=["resources"])
service = ResourceService()


@router.post("/", response_model=Resource, status_code=status.HTTP_201_CREATED)
def create_resource(data: ResourceCreate) -> Resource:
    """Crea un nuevo recurso."""
    return service.create_resource(data)


@router.get("/", response_model=List[Resource])
def list_resources() -> List[Resource]:
    """Lista todos los recursos."""
    return service.get_all_resources()


@router.get("/{resource_id}", response_model=Resource)
def get_resource(resource_id: int) -> Resource:
    """Obtiene un recurso especÃ­fico."""
    resource = service.get_resource(resource_id)
    if not resource:
        raise HTTPException(
            status_code=status.HTTP_404_NOT_FOUND,
            detail=f"Resource {resource_id} not found"
        )
    return resource
EOF

cat > src/api_service/main.py << 'EOF'
"""Punto de entrada de la aplicaciÃ³n."""
from fastapi import FastAPI
from .routes import resources


def create_app() -> FastAPI:
    """Factory para crear la aplicaciÃ³n."""
    app = FastAPI(
        title="API Service",
        description="Servicio API para gestiÃ³n de recursos",
        version="0.1.0"
    )
    
    # Registrar routers
    app.include_router(resources.router)
    
    @app.get("/")
    def root():
        return {"message": "API Service is running"}
    
    return app


app = create_app()
EOF
```

#### Paso 5: Crear tests

```bash
# Crear estructura de tests
mkdir -p tests/{test_routes,test_services}
touch tests/{test_routes,test_services}/__init__.py

cat > tests/conftest.py << 'EOF'
"""ConfiguraciÃ³n de pytest."""
import pytest
from fastapi.testclient import TestClient
from api_service.main import create_app


@pytest.fixture
def app():
    """Fixture de la aplicaciÃ³n."""
    return create_app()


@pytest.fixture
def client(app):
    """Fixture del cliente de pruebas."""
    return TestClient(app)
EOF

cat > tests/test_routes/test_resources.py << 'EOF'
"""Tests para rutas de recursos."""
import pytest


def test_root_endpoint(client):
    """Test del endpoint raÃ­z."""
    response = client.get("/")
    assert response.status_code == 200
    assert response.json() == {"message": "API Service is running"}


def test_create_resource(client):
    """Test de creaciÃ³n de recurso."""
    data = {
        "name": "Test Resource",
        "description": "A test resource",
        "active": True
    }
    response = client.post("/resources/", json=data)
    assert response.status_code == 201
    json_data = response.json()
    assert json_data["name"] == "Test Resource"
    assert "id" in json_data
    assert "created_at" in json_data


def test_list_resources(client):
    """Test de listado de recursos."""
    # Crear un recurso primero
    client.post("/resources/", json={"name": "Resource 1"})
    
    # Listar recursos
    response = client.get("/resources/")
    assert response.status_code == 200
    assert len(response.json()) >= 1


def test_get_resource(client):
    """Test de obtenciÃ³n de recurso especÃ­fico."""
    # Crear recurso
    create_response = client.post("/resources/", json={"name": "Resource X"})
    resource_id = create_response.json()["id"]
    
    # Obtener recurso
    response = client.get(f"/resources/{resource_id}")
    assert response.status_code == 200
    assert response.json()["name"] == "Resource X"


def test_get_nonexistent_resource(client):
    """Test de obtenciÃ³n de recurso inexistente."""
    response = client.get("/resources/9999")
    assert response.status_code == 404
EOF

cat > tests/test_services/test_resource_service.py << 'EOF'
"""Tests para el servicio de recursos."""
import pytest
from api_service.services.resource_service import ResourceService
from api_service.models.schemas import ResourceCreate


def test_create_resource():
    """Test de creaciÃ³n de recurso en el servicio."""
    service = ResourceService()
    data = ResourceCreate(name="Test", description="Testing")
    
    resource = service.create_resource(data)
    
    assert resource.id == 1
    assert resource.name == "Test"
    assert resource.description == "Testing"
    assert resource.active is True


def test_get_all_resources():
    """Test de obtenciÃ³n de todos los recursos."""
    service = ResourceService()
    
    # Crear varios recursos
    service.create_resource(ResourceCreate(name="Resource 1"))
    service.create_resource(ResourceCreate(name="Resource 2"))
    
    resources = service.get_all_resources()
    assert len(resources) == 2


def test_get_resource_by_id():
    """Test de obtenciÃ³n de recurso por ID."""
    service = ResourceService()
    created = service.create_resource(ResourceCreate(name="Test"))
    
    found = service.get_resource(created.id)
    assert found is not None
    assert found.name == "Test"
    
    not_found = service.get_resource(9999)
    assert not_found is None
EOF
```

#### Paso 6: Ejecutar el proyecto

```bash
# Ejecutar tests
uv run pytest

# Con cobertura
uv run pytest --cov=api_service --cov-report=html

# Ejecutar la API
uv run uvicorn api_service.main:app --reload

# Formatear cÃ³digo
uv run black src/ tests/

# Linting
uv run ruff check src/ tests/

# Type checking
uv run mypy src/
```

#### Paso 7: Scripts de automatizaciÃ³n

Agregar scripts en `pyproject.toml`:

```toml
[tool.uv]
dev-dependencies = [
    "pytest>=7.4.0",
    "pytest-asyncio>=0.21.0",
    "pytest-cov>=4.1.0",
]

[project.scripts]
serve = "uvicorn api_service.main:app --reload"
test = "pytest"
lint = "ruff check src/ tests/"
format = "black src/ tests/"
```

Luego ejecutar:

```bash
# Ejecutar servidor
uv run serve

# Ejecutar tests
uv run test
```

### ğŸ“¦ GestiÃ³n avanzada con UV

```bash
# Ver dependencias instaladas
uv pip list

# Congelar dependencias exactas
uv pip freeze > requirements.txt

# Instalar desde requirements.txt
uv pip install -r requirements.txt

# Actualizar todas las dependencias
uv sync --upgrade

# Verificar compatibilidad de dependencias
uv pip check

# Crear archivo .python-version para el proyecto
echo "3.11" > .python-version
uv sync  # UsarÃ¡ automÃ¡ticamente Python 3.11
```

### ğŸ”„ ComparaciÃ³n Poetry vs UV

| CaracterÃ­stica            | Poetry                          | UV                                   |
| ------------------------- | ------------------------------- | ------------------------------------ |
| **Velocidad**             | Moderada                        | Muy rÃ¡pida (escrito en Rust)         |
| **GestiÃ³n de entornos**   | Integrada                       | Usa venv estÃ¡ndar                    |
| **Lock file**             | poetry.lock (detallado)         | Compatible con pip                   |
| **Plugins**               | Extensible                      | Minimalista                          |
| **Curva de aprendizaje**  | Media                           | Baja (similar a pip)                 |
| **AdopciÃ³n**              | Muy popular                     | Creciente rÃ¡pidamente                |
| **Ideal para**            | Proyectos complejos y paquetes  | Velocidad y simplicidad              |

---

## ğŸ¯ 11) IntegraciÃ³n con herramientas de calidad

Ambas herramientas se integran perfectamente con el ecosistema de calidad de cÃ³digo Python:

### ConfiguraciÃ³n completa de `.pre-commit-config.yaml`

```yaml
repos:
  - repo: https://github.com/pre-commit/pre-commit-hooks
    rev: v4.5.0
    hooks:
      - id: trailing-whitespace
      - id: end-of-file-fixer
      - id: check-yaml
      - id: check-added-large-files
      - id: check-json
      - id: check-toml

  - repo: https://github.com/psf/black
    rev: 23.11.0
    hooks:
      - id: black

  - repo: https://github.com/astral-sh/ruff-pre-commit
    rev: v0.1.6
    hooks:
      - id: ruff
        args: [--fix]

  - repo: https://github.com/pre-commit/mirrors-mypy
    rev: v1.7.0
    hooks:
      - id: mypy
        additional_dependencies: [types-all]
```

Instalar hooks:

```bash
# Con Poetry
poetry add --group dev pre-commit
poetry run pre-commit install

# Con UV
uv add --dev pre-commit
uv run pre-commit install
```

### Archivo `.gitignore` completo

```gitignore
# Python
__pycache__/
*.py[cod]
*$py.class
*.so
.Python
build/
develop-eggs/
dist/
downloads/
eggs/
.eggs/
lib/
lib64/
parts/
sdist/
var/
wheels/
*.egg-info/
.installed.cfg
*.egg

# Entornos virtuales
.venv/
venv/
ENV/
env/

# Poetry
poetry.lock

# UV
uv.lock

# IDEs
.vscode/
.idea/
*.swp
*.swo
*~

# Testing
.pytest_cache/
.coverage
htmlcov/
.tox/

# Mypy
.mypy_cache/
.dmypy.json

# Notebooks
.ipynb_checkpoints/

# Variables de entorno
.env
.env.local

# OS
.DS_Store
Thumbs.db
```

---

## ğŸ§­ ConclusiÃ³n

La organizaciÃ³n de proyectos Python grandes y complejos requiere:

1. **Estructura clara y escalable** que separe concerns y facilite la navegaciÃ³n
2. **Herramientas modernas** como Poetry o UV para gestiÃ³n de dependencias reproducible
3. **AutomatizaciÃ³n** de tareas repetitivas (testing, linting, formatting)
4. **Buenas prÃ¡cticas** aplicadas consistentemente en todo el proyecto
5. **DocumentaciÃ³n** que acompaÃ±e el crecimiento del cÃ³digo

Tanto **Poetry** como **UV** ofrecen soluciones profesionales para gestionar proyectos complejos. La elecciÃ³n depende de las necesidades especÃ­ficas:

* **Poetry** â†’ Proyectos que se publicarÃ¡n como paquetes o requieren gestiÃ³n avanzada
* **UV** â†’ Proyectos que priorizan velocidad y simplicidad en el flujo de trabajo

Independientemente de la herramienta elegida, lo fundamental es establecer desde el inicio una estructura sÃ³lida que permita que el proyecto escale sin convertirse en un cÃ³digo inmanejable.

---

Publicar paquetes en Python, ya sea **pÃºblicos o internos**, permite **reutilizar, mantener y compartir** cÃ³digo de manera estructurada.
Los paquetes internos fortalecen la consistencia y escalabilidad dentro de una organizaciÃ³n, mientras que los pÃºblicos fomentan la colaboraciÃ³n y el crecimiento del ecosistema Python.

El dominio de estas prÃ¡cticas es clave para **profesionalizar el desarrollo** y facilitar la **integraciÃ³n continua** en proyectos modernos.
