# üêç M√≥dulo 3: Fundamentos de Python

## **Tema 3.1.3 ‚Äì Operadores y operaciones avanzadas para tipos de datos**

Este apunte complementa *‚ÄúTipos de Datos Avanzados‚Äù* y resume **operadores**, **operaciones entre bits**, y **m√©todos espec√≠ficos** √∫tiles para: `set`, `frozenset`, `Decimal`, `Fraction`, `complex`, `range`, `bytes`, `bytearray`, `memoryview` y `enum`. Incluye ejemplos cortos y notas pr√°cticas.

---

## üéØ Objetivo

* Conocer los **operadores nativos** asociados a los tipos avanzados.
* Practicar **operaciones bit a bit** (m√°scaras y flags) y su relaci√≥n con `bytes` y `enum.Flag`.
* Aplicar **m√©todos avanzados** (p. ej., `Decimal.quantize`, `Fraction.limit_denominator`, `memoryview.cast`, etc.).

---

## üßÆ 1) Operaciones bit a bit (enteros) y relaci√≥n con datos binarios

### Operadores bitwise

| Operador | Nombre        | Ejemplo           | Resultado                     |         |          |
| -------- | ------------- | ----------------- | ----------------------------- | ------- | -------- |
| `&`      | AND           | `0b1100 & 0b1010` | `0b1000`                      |         |          |
| `        | `             | OR                | `0b0101                       | 0b0011` | `0b0111` |
| `^`      | XOR           | `0b1100 ^ 0b1010` | `0b0110`                      |         |          |
| `~`      | NOT           | `~0b0101`         | `...1010` (complemento a dos) |         |          |
| `<<`     | Desplazar izq | `0b0011 << 2`     | `0b1100`                      |         |          |
| `>>`     | Desplazar der | `0b1100 >> 2`     | `0b0011`                      |         |          |

### Operadores booleanos avanzados

Los operadores **booleanos** trabajan con valores l√≥gicos (`True`/`False`) y son fundamentales en condiciones y expresiones compuestas. Adem√°s de los cl√°sicos `and`, `or`, `not`, Python soporta combinaciones avanzadas:

| Operador | Nombre     | Descripci√≥n                                            | Ejemplo             |
| -------- | ---------- | ------------------------------------------------------ | ------------------- |
| `and`    | Conjunci√≥n | Devuelve `True` si ambas condiciones son verdaderas    | `a > 0 and b > 0`   |
| `or`     | Disyunci√≥n | Devuelve `True` si al menos una condici√≥n es verdadera | `a == 0 or b == 0`  |
| `not`    | Negaci√≥n   | Invierte el valor l√≥gico                               | `not (a > b)`       |
| `^`      | XOR l√≥gico | Devuelve `True` si solo una condici√≥n es verdadera     | `(a > 0) ^ (b > 0)` |

> ‚öôÔ∏è **Nota:** En contextos booleanos, el operador `^` act√∫a como **XOR l√≥gico** (exclusivo). No existe `xand` o `nand` expl√≠citos, pero se pueden combinar `not` y `and/or` para obtener comportamientos equivalentes.

**M√°scaras y flags**

```python
READ, WRITE, EXEC = 0b001, 0b010, 0b100
permisos = READ | WRITE

# comprobar flag
tiene_write = bool(permisos & WRITE)

# activar y desactivar
permisos |= EXEC   # activa EXEC
permisos &= ~READ  # desactiva READ
```

**Con `bytes`/`bytearray`**

```python
pkt = bytearray(b"\x0f\xf0")
pkt[0] &= 0b1110  # limpia bit menos significativo ‚Üí 0x0e
```

---

## üî∏ 1.1) Representaci√≥n hexadecimal y bytes

El **sistema hexadecimal** (base 16) es ampliamente usado para representar valores binarios de forma compacta. Cada d√≠gito hexadecimal equivale a **4 bits** (medio byte), y dos d√≠gitos forman un **byte completo (8 bits)**.

### Conversi√≥n entre bases

```python
x = 255
print(hex(x))   # '0xff'
print(bin(x))   # '0b11111111'
print(int('ff', 16))  # 255
```

### Representaci√≥n de bytes en hexadecimal

```python
b = bytes([0x48, 0x69])
print(b)          # b'Hi'
print(b.hex())    # '4869'
print(bytes.fromhex('4869'))  # b'Hi'
```

> üí° El prefijo `0x` indica que el n√∫mero est√° en formato hexadecimal. Esto es especialmente √∫til para inspeccionar o depurar datos binarios, como archivos, buffers o protocolos de red.

---

## üî∑ 2) Conjuntos: `set` y `frozenset`

### Operadores de conjuntos

| Operador | Significado          | Ejemplo                  |        |                   |
| -------- | -------------------- | ------------------------ | ------ | ----------------- |
| `        | `                    | Uni√≥n                    | `{1,2} | {2,3} -> {1,2,3}` |
| `&`      | Intersecci√≥n         | `{1,2,3} & {2,4} -> {2}` |        |                   |
| `-`      | Diferencia           | `{1,2,3} - {2} -> {1,3}` |        |                   |
| `^`      | Diferencia sim√©trica | `{1,2} ^ {2,3} -> {1,3}` |        |                   |

### Comparaciones de inclusi√≥n

* `A <= B` (subconjunto), `A < B` (subconjunto propio)
* `A >= B` (superconjunto), `A > B` (superconjunto propio)

### M√©todos √∫tiles

```python
A = {1,2,3}; B = {3,4}
A.isdisjoint(B)   # True si no comparten elementos ‚Üí False
A.update(B)       # A = {1,2,3,4}
A.discard(5)      # no error si no existe
```

> `frozenset` soporta los mismos **operadores** pero es inmutable (sin `add/update/remove`).

---

## üí∞ 3) `Decimal` (precisi√≥n decimal exacta)

```python
from decimal import Decimal, getcontext, ROUND_HALF_UP
getcontext().prec = 10  # precisi√≥n global
x = Decimal('1.005')
print(x.quantize(Decimal('0.01'), rounding=ROUND_HALF_UP))  # 1.01
```

**Operaciones espec√≠ficas**

* `quantize(exp, rounding=...)`: redondeo exacto a un exponente dado.
* `scaleb(n)`: desplaza el punto decimal (x * 10**n).
* `normalize()`: remueve ceros a la derecha.
* `sqrt()`, `ln()`, `exp()` (dependen del contexto).

**Contexto y traps**

```python
ctx = getcontext()
ctx.traps[decimal.DivisionByZero] = True
```

---

## ‚ûó 4) `Fraction` (racionales exactos)

```python
from fractions import Fraction
f = Fraction(355, 113)
print(float(f))                    # 3.1415929...
print(f.limit_denominator(1000))   # aproxima con denom ‚â§ 1000
```

**Operaciones**: suma/resta/mult/div, `Fraction.from_float(0.1)`, `f.numerator`, `f.denominator`.

---

## ‚öõÔ∏è 5) `complex` (n√∫meros complejos)

```python
import cmath
z = 1 + 1j
print(z.conjugate())     # 1-1j
r, phi = cmath.polar(z)  # (m√≥dulo, argumento)
print(cmath.rect(r, phi))  # vuelve a forma a+bi
print(cmath.exp(1j*cmath.pi))  # ‚âà -1
```

**Operaciones**: `conjugate()`, m√≥dulo `abs(z)`, funciones de `cmath` (`sqrt`, `sin`, `cos`, `exp`, `phase`, `polar`, `rect`).

---

## üîÅ 6) `range` (secuencia inmutable)

```python
r = range(10, 0, -2)
print(len(r), r[0], r[-1])  # 5, 10, 2
print(8 in r)               # True
print(list(r[1:3]))         # [8, 6]
```

**Operaciones**: `len`, indexaci√≥n/slicing, pertenencia, pasos negativos.

---

## ‚öôÔ∏è 7) Binarios: `bytes`, `bytearray`, `memoryview`

### `bytes`

```python
d = bytes.fromhex("0a ff 1b")
print(d.hex())  # '0aff1b'
```

### `bytearray` (mutable)

```python
b = bytearray(b"ABC")
b[0] = ord('Z')
b.extend(b"\x00\x01")
print(b)  # bytearray(b'ZBC\x00\x01')
```

### `memoryview`

```python
buf = bytearray(b"abcdefgh")
mv = memoryview(buf)
print(bytes(mv[2:6]))  # b'cdef'
# reinterpretar como enteros de 2 bytes (little-endian)
ints = mv.cast('H')
print(list(ints))
```

> `memoryview.cast()` permite **reinterpretar** el buffer sin copiar memoria.

---

## üè∑Ô∏è 8) `enum`: `Enum`, `IntEnum` y `Flag`

```python
from enum import Enum, IntEnum, Flag, auto

class Estado(Enum):
    PENDIENTE = 1
    APROBADO = 2
    RECHAZADO = 3

class HTTP(IntEnum):
    OK = 200
    NOT_FOUND = 404

class Permiso(Flag):
    READ = auto()
    WRITE = auto()
    EXEC = auto()

p = Permiso.READ | Permiso.WRITE
print(Permiso.WRITE in p)    # True
p &= ~Permiso.READ           # limpia flag usando NOT bit a bit
```

**Notas**

* `IntEnum` se comporta como `int` (permite orden y operaciones num√©ricas si tiene sentido).
* `Flag` est√° dise√±ado para **componer flags** con operadores bitwise (`|`, `&`, `~`).

---

## üìå Tips y precauciones

* `Decimal`/`Fraction` son m√°s **precisos**, pero **m√°s lentos** que `float`.
* `set` no preserva orden; si necesit√°s orden + unicidad, considerar `dict.fromkeys()` o `OrderedDict`/`set` + sorted.
* `bytes` son inmutables; si necesit√°s editar, usar `bytearray`.
* `memoryview` es poderoso en **I/O binario** y **numpy-like slicing** sin copias.
* `Enum.Flag` + bitwise simplifica permisos/estados compuestos.

---

## üß≠ Tabla r√°pida de operadores por tipo

| Tipo              | Operadores clave                                               |                                                      |
| ----------------- | -------------------------------------------------------------- | ---------------------------------------------------- |
| `int` (bit a bit) | `&`, `                                                         | `, `^`, `~`, `<<`, `>>`                              |
| `set`/`frozenset` | `                                                              | `, `&`, `-`, `^`, comparaciones `<=`, `<`, `>=`, `>` |
| `Decimal`         | `+`, `-`, `*`, `/`, `//`, `%`, `quantize`, `sqrt`, contexto    |                                                      |
| `Fraction`        | `+`, `-`, `*`, `/`, `limit_denominator`, numerador/denominador |                                                      |
| `complex`         | `+`, `-`, `*`, `/`, `conjugate`, `abs`, `cmath.*`              |                                                      |
| `range`           | `len`, indexado, slicing, `in`                                 |                                                      |
| `bytes`           | concatenaci√≥n, slicing, `fromhex`, `hex`                       |                                                      |
| `bytearray`       | idem `bytes` + asignaci√≥n, `extend`, mutaci√≥n                  |                                                      |
| `memoryview`      | slicing sin copia, `cast`                                      |                                                      |
| `enum.Flag`       | `                                                              | `, `&`, `^`, `~` para combinar/limpiar flags         |

---

> ‚úÖ Conocer y practicar estos **operadores** y **m√©todos espec√≠ficos** te permite escribir soluciones m√°s **eficientes** y **precisas**, especialmente en aplicaciones num√©ricas, binarias y de manipulaci√≥n de estructuras complejas.
