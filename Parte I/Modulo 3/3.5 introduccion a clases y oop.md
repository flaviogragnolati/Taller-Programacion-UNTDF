# üêç M√≥dulo 3: Fundamentos de Python

## **Tema 3.5 ‚Äì Introducci√≥n a clases y objetos (OOP b√°sica: atributos, m√©todos, instanciaci√≥n)**

En este tema se introducen los **conceptos esenciales de Programaci√≥n Orientada a Objetos (OOP)** en Python: qu√© es una **clase**, qu√© es un **objeto**, c√≥mo definir **atributos** y **m√©todos**, y c√≥mo crear instancias. Tambi√©n se exploran los pilares fundamentales de la OOP: **herencia**, **composici√≥n**, **encapsulamiento**, **polimorfismo** y **mutabilidad**, junto con el uso de **decoradores** y buenas pr√°cticas.

---

## üß© 1) Conceptos b√°sicos de clases y objetos

* **Clase**: molde o plantilla que define los **datos** (atributos) y **comportamientos** (m√©todos).
* **Objeto** (instancia): realizaci√≥n concreta de una clase.
* **Atributo**: variable asociada a una clase u objeto.
* **M√©todo**: funci√≥n definida dentro de la clase, cuyo primer par√°metro suele ser `self` (la instancia).

```python
class Punto:
    def __init__(self, x: float, y: float):
        self.x = x
        self.y = y

    def mover(self, dx: float, dy: float):
        self.x += dx
        self.y += dy

p = Punto(1.0, 2.0)
p.mover(0.5, -1.0)
print(p.x, p.y)  # 1.5 1.0
```

---

## üß± 2) Atributos: de instancia vs de clase

```python
class Contador:
    instancias = 0  # atributo de clase (compartido)

    def __init__(self):
        self.valor = 0  # atributo de instancia (√∫nico por objeto)
        Contador.instancias += 1

    def inc(self, paso: int = 1):
        self.valor += paso

c1 = Contador(); c2 = Contador()
c1.inc(); c2.inc(3)
print(c1.valor, c2.valor)  # 1 3
print(Contador.instancias)  # 2
```

---


## üß∞ 3) M√©todos de clase y est√°ticos

* `@classmethod`: opera a nivel de clase (recibe `cls`).
* `@staticmethod`: funci√≥n utilitaria dentro de la clase.

```python
class Temperatura:
    def __init__(self, celsius: float):
        self.celsius = celsius

    @classmethod
    def desde_fahrenheit(cls, f: float):
        return cls((f - 32) * 5 / 9)

    @staticmethod
    def es_valida_celsius(t: float):
        return -273.15 <= t

T = Temperatura.desde_fahrenheit(98.6)
print(T.celsius)
```

---

## ‚öôÔ∏è 3.1) M√©todos especiales (*dunder methods*)

Los m√©todos **dunder** (por *double underscore*, es decir, doble guion bajo) son funciones especiales que permiten personalizar el comportamiento de los objetos.

```python
class Producto:
    def __init__(self, codigo: str, nombre: str, precio: float):
        self.codigo = codigo
        self.nombre = nombre
        self.precio = precio

    def __repr__(self):
        return f"Producto(codigo={self.codigo!r}, nombre={self.nombre!r}, precio={self.precio!r})"

    def __str__(self):
        return f"{self.nombre} (${self.precio:.2f})"

p = Producto("A1", "Lapicera", 1200.0)
print(repr(p))
print(p)
```

### üß≠ Tabla resumen de m√©todos *dunder* m√°s frecuentes

| M√©todo                   | Descripci√≥n                            | Ejemplo         |
| ------------------------ | -------------------------------------- | --------------- |
| `__init__`               | Constructor: inicializa atributos      | `obj = Clase()` |
| `__repr__`               | Representaci√≥n t√©cnica para depuraci√≥n | `repr(obj)`     |
| `__str__`                | Representaci√≥n legible para usuarios   | `print(obj)`    |
| `__eq__`                 | Igualdad l√≥gica                        | `obj1 == obj2`  |
| `__lt__`                 | Comparaci√≥n menor que                  | `obj1 < obj2`   |
| `__len__`                | Longitud o tama√±o l√≥gico               | `len(obj)`      |
| `__iter__`               | Iterador                               | `for x in obj:` |
| `__getitem__`            | Acceso por √≠ndice                      | `obj[i]`        |
| `__setitem__`            | Asignaci√≥n por √≠ndice                  | `obj[i] = v`    |
| `__call__`               | Hace invocable al objeto               | `obj()`         |
| `__enter__` / `__exit__` | Gesti√≥n de contexto (`with`)           | `with obj:`     |

---

## üß∑ 4) Encapsulamiento, properties y *name mangling*

Python usa convenciones para el **encapsulamiento**:

* `_atributo`: indica uso interno (no modificar desde fuera).
* `__atributo`: activa *name mangling* (enmascaramiento de nombre) para evitar colisiones en subclases.

```python
class Cuenta:
    def __init__(self, titular: str, saldo: float = 0.0):
        self._titular = titular
        self.__saldo = saldo  # privado (name mangling)

    @property
    def saldo(self) -> float:
        return self.__saldo

    def depositar(self, monto: float):
        if monto <= 0:
            raise ValueError("monto debe ser positivo")
        self.__saldo += monto
```

### üîí *name mangling*

El **name mangling** es un mecanismo que renombra internamente los atributos con `__doble_guion__` para evitar conflictos de nombres.
Por ejemplo, `self.__saldo` se convierte en `_Cuenta__saldo` dentro de la clase.

---

## üéÄ 5) Decoradores en OOP y funciones

Los **decoradores** son funciones que reciben otra funci√≥n o clase y devuelven una versi√≥n modificada. Se usan para **a√±adir funcionalidad** sin cambiar el c√≥digo original.

```python
def registrar(func):
    def wrapper(*args, **kwargs):
        print(f"Ejecutando {func.__name__}...")
        resultado = func(*args, **kwargs)
        print("Finalizado.")
        return resultado
    return wrapper

@registrar
def saludar(nombre):
    print(f"Hola, {nombre}!")

saludar("Luc√≠a")
```

### üß© Tabla de decoradores comunes

| Decorador              | √Åmbito              | Funci√≥n principal                   | Ejemplo         |
| ---------------------- | ------------------- | ----------------------------------- | --------------- |
| `@property`            | M√©todo de instancia | Define atributo calculado           | `@property`     |
| `@<prop>.setter`       | M√©todo de instancia | Define m√©todo para asignar property | `@saldo.setter` |
| `@classmethod`         | Clase               | M√©todo que recibe la clase (`cls`)  | `@classmethod`  |
| `@staticmethod`        | Clase               | Funci√≥n sin `self/cls`              | `@staticmethod` |
| `@dataclass`           | Clase               | Genera m√©todos autom√°ticos          | `@dataclass`    |
| `@functools.lru_cache` | Funci√≥n             | Cachea resultados                   | `@lru_cache`    |
| `@wraps`               | Funci√≥n decoradora  | Preserva metadatos                  | `@wraps(func)`  |

---


## üß± 6) Conceptos te√≥ricos de OOP: Herencia, Composici√≥n, Polimorfismo, Encapsulamiento y Mutabilidad

### üîπ Herencia

Permite crear una clase hija que hereda atributos y m√©todos de una clase base.

### üîπ Composici√≥n

Una clase contiene instancias de otras clases; es una relaci√≥n *tiene-un*.

### üîπ Polimorfismo

Diferentes clases pueden implementar el mismo m√©todo de forma distinta.

### üîπ Encapsulamiento

Controla el acceso a los datos internos del objeto, protegiendo su consistencia.

### üîπ Mutabilidad

Las instancias pueden ser mutables (estado modificable) o inmutables (constantes).

### üìä Tabla: Ventajas y desventajas de la OOP

| Ventajas                                   | Desventajas                                             |
| ------------------------------------------ | ------------------------------------------------------- |
| Favorece la reutilizaci√≥n y modularidad    | Puede ser m√°s compleja que la programaci√≥n estructurada |
| Facilita el mantenimiento y escalabilidad  | Overhead en proyectos peque√±os                          |
| Permite modelar el mundo real              | Excesiva abstracci√≥n puede reducir claridad             |
| Extensible mediante herencia y composici√≥n | Posible acoplamiento entre clases                       |

### üí° Cu√°ndo aplicar OOP

* Cuando hay **entidades con datos y comportamientos asociados**.
* Cuando el dominio tiene **jerarqu√≠as naturales o relaciones** entre objetos.
* Cuando se busca **extensibilidad y mantenibilidad** del c√≥digo.
* Evitar en scripts simples o c√°lculos puramente funcionales.

---

## üßæ 7) `dataclasses`: clases de datos r√°pidas

```python
from dataclasses import dataclass

@dataclass
class Medicion:
    sensor: str
    valor: float
    unidad: str = "¬∞C"

m = Medicion("S1", 21.7)
print(m)
```

---

## ‚úÖ 8) Buenas pr√°cticas iniciales

* Tipar y documentar atributos en `__init__`.
* Definir `__repr__` √∫til.
* Validar entradas en m√©todos.
* Preferir composici√≥n sobre herencia cuando sea m√°s simple.

---

## üß™ 9) Ejemplo integrador: Gestor de cuenta bancaria simple

## üß™ Ejemplo integrador: Gestor de cuenta bancaria simple

### üéØ Objetivo
Modelar una **cuenta bancaria** con operaciones de **dep√≥sito**, **extracci√≥n**, **registro de movimientos**, y utilidades de f√°brica.  
El ejemplo aplica los conceptos vistos: **atributos de instancia y clase**, **m√©todos**, **encapsulamiento**, **decoradores**, **validaci√≥n de errores** y **m√©todos especiales**.

---

### üíª C√≥digo completo (en un solo archivo)
```python
from __future__ import annotations
from dataclasses import dataclass
from datetime import datetime
from typing import List, Literal

MovimientoTipo = Literal["deposito", "extraccion"]

@dataclass
class Movimiento:
    fecha: datetime
    tipo: MovimientoTipo
    monto: float
    saldo_resultante: float


class CuentaBancaria:
    # Atributo de clase compartido por todas las cuentas
    costo_extraccion: float = 0.0

    def __init__(self, titular: str, saldo_inicial: float = 0.0):
        if saldo_inicial < 0:
            raise ValueError("El saldo inicial no puede ser negativo.")
        self.titular = titular
        self._saldo = saldo_inicial
        self._movimientos: List[Movimiento] = []

    def __repr__(self) -> str:
        return f"CuentaBancaria(titular={self.titular!r}, saldo={self._saldo:.2f})"

    @property
    def saldo(self) -> float:
        """Devuelve el saldo actual de la cuenta."""
        return self._saldo

    def _registrar(self, tipo: MovimientoTipo, monto: float) -> None:
        """Registra internamente cada movimiento con fecha y saldo resultante."""
        self._movimientos.append(
            Movimiento(datetime.now(), tipo, monto, self._saldo)
        )

    @staticmethod
    def _validar_monto(monto: float) -> None:
        """Valida que el monto sea positivo."""
        if monto <= 0:
            raise ValueError("El monto debe ser positivo.")

    def depositar(self, monto: float) -> None:
        """Agrega dinero a la cuenta."""
        self._validar_monto(monto)
        self._saldo += monto
        self._registrar("deposito", monto)

    def extraer(self, monto: float) -> None:
        """Resta dinero de la cuenta, aplicando costo de extracci√≥n."""
        self._validar_monto(monto)
        total = monto + self.costo_extraccion
        if total > self._saldo:
            raise ValueError("Fondos insuficientes.")
        self._saldo -= total
        self._registrar("extraccion", -total)

    def historial(self) -> List[Movimiento]:
        """Devuelve la lista de movimientos registrados."""
        return list(self._movimientos)

    @classmethod
    def con_bienvenida(cls, titular: str) -> CuentaBancaria:
        """Crea una cuenta con saldo inicial de bienvenida."""
        return cls(titular, saldo_inicial=1000.0)


# ===== Ejemplo de uso =====
if __name__ == "__main__":
    CuentaBancaria.costo_extraccion = 50.0
    cuenta = CuentaBancaria.con_bienvenida("Luc√≠a")

    print(cuenta)  # Representaci√≥n por __repr__

    cuenta.depositar(500)
    print("Saldo tras dep√≥sito:", cuenta.saldo)

    try:
        cuenta.extraer(1200)
    except ValueError as e:
        print("Error al extraer:", e)

    cuenta.extraer(200)
    print("Saldo final:", cuenta.saldo)

    print("\nHistorial de movimientos:")
    for mov in cuenta.historial():
        print(
            mov.fecha.strftime("%H:%M:%S"),
            mov.tipo,
            mov.monto,
            "=>",
            mov.saldo_resultante,
        )
```
### üìä Resultado esperado (aproximado)
```
CuentaBancaria(titular='Luc√≠a', saldo=1000.00)
Saldo tras dep√≥sito: 1500.0
Error al extraer: Fondos insuficientes.
Saldo final: 1250.0

Historial de movimientos:
14:23:10 deposito 500.0 => 1500.0
14:23:15 extraccion -250.0 => 1250.0
```

---

## üìö Recursos recomendados

* **Documentaci√≥n oficial de Python:**
  [Classes ‚Äì Python Docs](https://docs.python.org/3/tutorial/classes.html)
  [Data model (m√©todos especiales)](https://docs.python.org/3/reference/datamodel.html)

* **Gu√≠as introductorias:**
  [Real Python ‚Äì Object-Oriented Programming](https://realpython.com/python3-object-oriented-programming/)
  [Programiz ‚Äì Python OOP](https://www.programiz.com/python-programming/object-oriented-programming)

* **Recursos te√≥ricos de OOP:**
  [Grady Booch ‚Äì Object-Oriented Analysis and Design](https://en.wikipedia.org/wiki/Object-oriented_analysis_and_design)
  [SOLID Principles ‚Äì Medium Guide](https://medium.com/@cramirez92/s-o-l-i-d-principles-explained-in-python-ac7e92cc1d53)

---

> ‚úÖ Con estas bases de OOP pod√©s modelar sistemas m√°s organizados, reutilizables y mantenibles, aplicando principios de encapsulamiento, herencia, composici√≥n y polimorfismo con buenas pr√°cticas modernas.
