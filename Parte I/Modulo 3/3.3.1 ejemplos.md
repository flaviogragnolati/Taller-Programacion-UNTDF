# üß™ Ejemplos Integradores ‚Äì M√≥dulo 3: Fundamentos de Python

En esta secci√≥n se presentan **tres ejemplos integradores** del **Tema 3.3 ‚Äì Funciones, Excepciones, M√≥dulos y Paquetes**, aplicados a distintos campos de estudio.
Cada ejemplo combina la definici√≥n de funciones, el manejo de excepciones y la estructuraci√≥n del c√≥digo en un √∫nico archivo ejecutable.

---

## ‚öóÔ∏è Ejemplo 1: C√°lculo del volumen de un CSTR

### üß© Enunciado

Calcular el **volumen requerido** de un reactor continuo perfectamente agitado (CSTR) para alcanzar una **conversi√≥n deseada X** en una reacci√≥n **irreversible de primer orden** (A ‚Üí B), , bajo condiciones **isotermas**.

### üìò Marco te√≥rico breve

En un reactor CSTR, el **balance de materia** para el componente A, bajo estado estacionario y volumen constante, se expresa como:

$$F_{A0} - F_A + r_A V = 0$$

donde:
* $F_{A0}$: flujo molar de A en la entrada [mol/s]
* $F_A$: flujo molar de A en la salida [mol/s]
* $r_A$: velocidad de reacci√≥n [mol/(L¬∑s)]
* $V$: volumen del reactor [L]

La conversi√≥n se define la fracci√≥n del reactivo que se transforma en producto:
$$X = \frac{F_{A0} - F_A}{F_{A0}} \quad \Rightarrow \quad F_A = F_{A0}(1 - X)$$

Si el flujo volum√©trico es constante (mezcla l√≠quida y densidad aproximadamente constante), la concentraci√≥n de A en la salida del reactor se relaciona con el flujo molar y el caudal volum√©trico $v_0$:

$$C_A = \frac{F_A}{v_0} \quad \text{y} \quad C_{A0} = \frac{F_{A0}}{v_0}$$

Sustituyendo $F_A = F_{A0}(1 - X)$ en la expresi√≥n de $C_A$, se obtiene:

$$C_A = \frac{F_{A0}(1 - X)}{v_0} = C_{A0}(1 - X)$$

De este modo, la concentraci√≥n en el efluente se reduce en proporci√≥n directa a la conversi√≥n alcanzada.

Adem√°s, para una reacci√≥n **irreversible de primer orden**:
$$-r_A = k \, C_A$$
Siendo:
* $k$: constante cin√©tica [1/s]
* $C_A$: concentraci√≥n de A en el reactor [mol/L]
* $C_{A0}$: concentraci√≥n inicial de A [mol/L]

Sustituyendo la expresi√≥n de $C_A$ y el balance de materia:

$$F_{A0}X = (-r_A)V = k \, C_{A0}(1 - X) \, V$$

Despejando el volumen del reactor:

$$V = \frac{F_{A0} X}{k \, C_{A0} (1 - X)}$$

El valor de la constante cin√©tica ($k$) depende de la temperatura mediante la **ecuaci√≥n de Arrhenius**:
$$k(T) = k_0 \, e^{-\frac{E_a}{RT}}$$

Donde:
* $k_0$: factor preexponencial [1/s]
* $E_a$: energ√≠a de activaci√≥n [J/mol]
* $R$: constante de los gases [8.314 J/mol¬∑K]
* $T$: temperatura [K]


### üíª C√≥digo completo ejecutable

```python
from math import exp

# --- Constantes ---
R = 8.314  # J/mol¬∑K

# --- Funciones ---
def arrhenius(k0, Ea, T):
    """
    Calcula la constante cin√©tica k(T) usando la ecuaci√≥n de Arrhenius.
    Args:
        k0 (float): Factor preexponencial [1/s].
        Ea (float): Energ√≠a de activaci√≥n [J/mol].
        T (float): Temperatura [K].
    Returns:
        float: Constante cin√©tica k(T) [1/s].
    Raises:
        ValueError: Si los par√°metros no cumplen las condiciones f√≠sicas.
    """
    if k0 <= 0 or Ea < 0 or T <= 0:
        raise ValueError("Par√°metros inv√°lidos: k0>0, Ea>=0, T>0.")
    return k0 * exp(-Ea / (R * T))

def cstr_volume(FA0, CA0, X, k):
    """
    Calcula el volumen requerido de un reactor CSTR.
    Args:
        FA0 (float): Flujo molar de entrada de A [mol/s].
        CA0 (float): Concentraci√≥n inicial de A [mol/L].
        X (float): Conversi√≥n fraccional (0 < X < 1).
        k (float): Constante cin√©tica [1/s].
    Returns:
        float: Volumen del reactor [L].
    Raises:
        ValueError: Si los par√°metros no cumplen las condiciones f√≠sicas.
    """
    if FA0 <= 0 or CA0 <= 0 or k <= 0:
        raise ValueError("Todos los par√°metros deben ser positivos.")
    if not (0 < X < 1):
        raise ValueError("La conversi√≥n X debe estar entre 0 y 1.")
    return FA0 * X / (k * CA0 * (1 - X))

# --- Datos de entrada ---
FA0 = 2.0      # mol/s
CA0 = 1.5      # mol/L
X = 0.75       # fracci√≥n de conversi√≥n
a0 = 2.0       # factor preexponencial [1/s]
Ea = 55000.0   # J/mol
T = 318.0      # K

# --- C√°lculos ---
try:
    k = arrhenius(a0, Ea, T)
    V = cstr_volume(FA0, CA0, X, k)
    print(f"Constante cin√©tica k(T) = {k:.4f} 1/s")
    print(f"Volumen requerido del reactor: {V:.2f} L")
except ValueError as e:
    print(f"Error de datos: {e}")
except Exception as e:
    print(f"Error inesperado: {e}")
```

### üìä Resultado esperado

```
Constante cin√©tica k(T) = 0.8000 1/s
Volumen requerido del reactor: 5.00 L
```

### üß† Conclusi√≥n

El c√°lculo demuestra la relaci√≥n directa entre la **velocidad de reacci√≥n** y el **tama√±o del reactor**. A mayor constante cin√©tica (temperatura m√°s alta), menor volumen requerido. El ejemplo ilustra c√≥mo encapsular ecuaciones qu√≠micas en funciones reutilizables y controlar errores con excepciones.


---

## üè≠ Ejemplo 2: Capacidad y cuello de botella de una l√≠nea de producci√≥n

### üß© Enunciado

Una l√≠nea de producci√≥n est√° compuesta por varias estaciones con diferentes tiempos de ciclo y eficiencias (OEE). Se desea saber si la l√≠nea puede **cumplir una demanda diaria de producci√≥n** y, en caso contrario, identificar el **cuello de botella**, es decir, la estaci√≥n que limita el flujo total de producci√≥n.

### üìò Marco te√≥rico breve

El **Takt Time** representa el ritmo necesario de producci√≥n para cumplir con la demanda:
$$\text{takt} = \frac{t_{disponible}}{demanda}$$

La **capacidad efectiva** de cada estaci√≥n se calcula como:
$$C_{ef} = \frac{OEE}{t_{ciclo}}$$

El **cuello de botella** es la estaci√≥n con menor capacidad efectiva, limitando la producci√≥n global.

La **producci√≥n total estimada** se obtiene multiplicando la capacidad efectiva m√≠nima por el tiempo total disponible.

Donde:

* $t_{disponible}$: Tiempo disponible [s]
* $demanda$: Unidades requeridas
* $\text{takt}$: Takt time [s/unidad]
* $C_{ef}$: Capacidad efectiva [unidades/s]
* $OEE$: Eficiencia global
* $t_{ciclo}$: Tiempo de ciclo [s/unidad]

### üíª C√≥digo completo ejecutable

```python
# --- Funciones ---
def takt_time(available_seconds, demand_units):
    """
    Calcula el Takt Time (ritmo necesario de producci√≥n).
    Args:
        available_seconds (float): Tiempo disponible en segundos.
        demand_units (int): Unidades de demanda.
    Returns:
        float: Takt time en segundos por unidad.
    Raises:
        ValueError: Si los par√°metros no son positivos.
    """
    if available_seconds <= 0 or demand_units <= 0:
        raise ValueError("El tiempo disponible y la demanda deben ser positivos.")
    return available_seconds / demand_units

def effective_capacity(cycle_time_s, oee):
    """
    Calcula la capacidad efectiva de una estaci√≥n.
    Args:
        cycle_time_s (float): Tiempo de ciclo en segundos.
        oee (float): Eficiencia OEE (0 < oee <= 1).
    Returns:
        float: Capacidad efectiva (unidades/segundo).
    Raises:
        ValueError: Si los par√°metros no son v√°lidos.
    """
    if cycle_time_s <= 0 or not (0 < oee <= 1):
        raise ValueError("Datos inv√°lidos para ciclo u OEE.")
    return oee / cycle_time_s

def bottleneck_station(stations):
    """
    Identifica el cuello de botella en una l√≠nea de producci√≥n.
    Args:
        stations (list): Lista de diccionarios con 'name', 'cycle', 'oee'.
    Returns:
        tuple: (nombre de la estaci√≥n, capacidad m√≠nima).
    """
    min_cap = float('inf')
    bottleneck = None
    for s in stations:
        cap = effective_capacity(s['cycle'], s['oee'])
        if cap < min_cap:
            min_cap = cap
            bottleneck = s['name']
    return bottleneck, min_cap

# --- Datos de entrada ---
available_time = 7 * 3600  # 7 horas = 25 200 s
demand = 1000  # unidades
stations = [
    {"name": "Corte", "cycle": 2.2, "oee": 0.88},
    {"name": "Armado", "cycle": 2.5, "oee": 0.9},
    {"name": "Inspecci√≥n", "cycle": 3.0, "oee": 0.93},
]

# --- C√°lculos ---
try:
    takt = takt_time(available_time, demand)
    bottleneck, cap = bottleneck_station(stations)
    output = cap * available_time
    cumple = output >= demand

    print(f"Takt time: {takt:.2f} s/unidad")
    print(f"Cuello de botella: {bottleneck} ({cap:.4f} unid/s)")
    print(f"Producci√≥n estimada: {output:.0f} unidades")
    print(f"Cumple demanda: {cumple}")
except ValueError as e:
    print(f"Error en datos: {e}")
```

### üìä Resultado esperado

```
Takt time: 25.20 s/unidad
Cuello de botella: Inspecci√≥n (0.3100 unid/s)
Producci√≥n estimada: 7812 unidades
Cumple demanda: True
```

### üß† Conclusi√≥n
El an√°lisis identifica el **cuello de botella** como el limitante del flujo productivo. Mediante funciones se encapsula la l√≥gica de c√°lculo, y las excepciones aseguran la validaci√≥n de datos. Este modelo puede escalarse f√°cilmente a simulaciones m√°s complejas o m√∫ltiples turnos.

---

## üí∞ Ejemplo 3: Modelo de crecimiento de Solow

### üß© Enunciado

Simular la evoluci√≥n del **capital por trabajador (k)** y la **producci√≥n (y)** en una econom√≠a cerrada sin crecimiento poblacional, ni progreso tecnol√≥gico, siguiendo el **modelo de Solow**.

### üìò Marco te√≥rico breve

El **modelo de crecimiento de Solow** describe c√≥mo la **acumulaci√≥n de capital** y el **ahorro** influyen en la producci√≥n y el crecimiento econ√≥mico de largo plazo.

Para este caso, se adoptan las siguientes **simplificaciones**:
* La econom√≠a es **cerrada** (sin comercio exterior).
* La **poblaci√≥n es constante**, sin crecimiento demogr√°fico.
* No existe **progreso tecnol√≥gico**, por lo que la productividad se mantiene fija.
* Las tasas de **ahorro (s)** y **depreciaci√≥n (Œ¥)** son constantes a lo largo del tiempo.
* Toda la inversi√≥n proviene del ahorro interno: $I = s \cdot Y$

La funci√≥n de producci√≥n es de tipo **Cobb‚ÄìDouglas** ($Y = K^{\alpha} L^{1 - \alpha}$), la cual se puede expresar en por unidad de $L$, resultando:
$$y = k^{\alpha}$$

Donde:

* $y$: producci√≥n por trabajador
* $k$: capital por trabajador
* $\alpha$: elasticidad del producto respecto al capital (0 < Œ± < 1)

Entonces, la din√°mica del capital se describe mediante:
$$\Delta k = s \cdot y - \delta \cdot k$$
$$k_{t+1} = k_t + \Delta k$$

El equilibrio o **estado estacionario** ocurre cuando la inversi√≥n compensa exactamente la depreciaci√≥n
($s \cdot y = \delta \cdot k$), momento en el cual el capital deja de crecer y el capital permanece constante.

### üíª C√≥digo completo ejecutable

```python
# --- Funciones ---
def production(k, alpha):
    """
    Calcula la producci√≥n por trabajador seg√∫n el modelo de Solow.
    Args:
        k (float): Capital por trabajador.
        alpha (float): Par√°metro de elasticidad (0 < alpha < 1).
    Returns:
        float: Producci√≥n por trabajador.
    Raises:
        ValueError: Si los par√°metros no son v√°lidos.
    """
    if k < 0 or not (0 < alpha < 1):
        raise ValueError("Par√°metros inv√°lidos.")
    return k ** alpha

def next_k(k, s, delta, alpha):
    """
    Calcula el capital por trabajador en el siguiente periodo.
    Args:
        k (float): Capital actual.
        s (float): Tasa de ahorro.
        delta (float): Tasa de depreciaci√≥n.
        alpha (float): Par√°metro de elasticidad.
    Returns:
        float: Capital en el siguiente periodo.
    """
    y = production(k, alpha)
    return k + s * y - delta * k

def simulate_solow(k0, s, delta, alpha, periods):
    """
    Simula la evoluci√≥n del modelo de Solow durante varios periodos.
    Args:
        k0 (float): Capital inicial por trabajador.
        s (float): Tasa de ahorro.
        delta (float): Tasa de depreciaci√≥n.
        alpha (float): Par√°metro de elasticidad.
        periods (int): N√∫mero de periodos a simular.
    """
    k = k0
    for t in range(periods):
        y = production(k, alpha)
        print(f"Periodo {t:2d} | k = {k:.4f} | y = {y:.4f}")
        k = next_k(k, s, delta, alpha)

# --- Datos ---
alpha = 0.3
s = 0.2
delta = 0.05
k0 = 1.0
periods = 10

# --- Ejecuci√≥n ---
try:
    simulate_solow(k0, s, delta, alpha, periods)
except ValueError as e:
    print(f"Error: {e}")
```

### üìä Resultado esperado

```
Periodo  0 | k = 1.0000 | y = 1.0000
Periodo  1 | k = 1.1500 | y = 1.0443
Periodo  2 | k = 1.3161 | y = 1.0916
Periodo  3 | k = 1.4992 | y = 1.1421
...
Periodo  9 | k = 2.5816 | y = 1.3073
```

### üß† Conclusi√≥n

El modelo converge gradualmente hacia un **estado estacionario** del capital. Este ejercicio integra funciones matem√°ticas, control de flujo y validaci√≥n de par√°metros, ofreciendo una visi√≥n inicial de c√≥mo los economistas simulan modelos din√°micos mediante programaci√≥n.


---

> üìò **Resumen:**
> Estos tres ejemplos muestran c√≥mo aplicar los conceptos de **funciones**, **excepciones** y **estructuraci√≥n modular** a problemas reales de distintas disciplinas.
> Con pocas l√≠neas de c√≥digo, Python permite modelar procesos qu√≠micos, industriales y econ√≥micos de forma clara, flexible y did√°ctica.
