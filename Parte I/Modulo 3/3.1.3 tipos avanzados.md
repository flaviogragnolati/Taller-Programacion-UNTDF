# 🐍 Módulo 3: Fundamentos de Python

## **Tema 3.1.3 – Tipos de Datos Avanzados en Python**

---

## 🎯 Objetivo

Comprender los **tipos de datos avanzados** que ofrece Python más allá de los básicos (int, float, str, bool, list, dict, tuple).
Aprender sus características, usos más comunes y cómo aprovecharlos para escribir programas más **eficientes, precisos y expresivos**.

---

## 🧭 Introducción

Python incluye una serie de **tipos de datos especializados** diseñados para resolver problemas específicos. Algunos permiten trabajar con **colecciones inmutables**, otros mejoran la **precisión numérica**, o brindan herramientas para **procesar datos binarios**.
Estos tipos avanzados se encuentran en el **núcleo del lenguaje** o en **módulos estándar** como `decimal`, `fractions`, `enum` o `math`.

En este tema exploraremos:

* `frozenset`: conjunto de elementos únicos e inmutables.
* `Decimal` y `Fraction`: números racionales y decimales exactos.
* `complex`: números complejos.
* `range`: secuencias numéricas inmutables.
* `bytes`, `bytearray` y `memoryview`: manejo de datos binarios.
* `enum`: enumeraciones simbólicas.

---

## 🧩 1) Conjuntos: `frozenset`

### 🔹 `set`

Colección **no ordenada**, **mutable** y sin elementos duplicados.

```python
frutas = {"manzana", "pera", "banana"}
frutas.add("naranja")
frutas.discard("banana")
print(frutas)  # {'manzana', 'pera', 'naranja'}

# Operaciones de conjuntos
A = {1, 2, 3}; B = {3, 4, 5}
print(A | B)  # unión → {1, 2, 3, 4, 5}
print(A & B)  # intersección → {3}
print(A - B)  # diferencia → {1, 2}
```

### 🔹 `frozenset`

Versión **inmutable** de `set`. Ideal para usar como clave en diccionarios o elemento en otros conjuntos.

```python
numeros = frozenset([1, 2, 3, 4])
print(numeros)
# numeros.add(5)  → ❌ error (inmutable)
```

---

## 🔢 2) Tipos numéricos avanzados

### 🔹 `Decimal` (módulo `decimal`)

Usado para **cálculos financieros o científicos** donde se requiere precisión exacta (sin errores binarios típicos de float).

```python
from decimal import Decimal, getcontext

getcontext().prec = 6  # precisión de 6 dígitos
a = Decimal('1.1')
b = Decimal('2.2')
print(a + b)  # 3.3 exactamente
```

### 🔹 `Fraction` (módulo `fractions`)

Representa números racionales como fracciones exactas (numerador/denominador).

```python
from fractions import Fraction

f1 = Fraction(3, 4)
f2 = Fraction(1, 2)
print(f1 + f2)  # 5/4
print(float(f1))  # 0.75
```

### 🔹 `complex`

Soporta **números complejos** (parte real e imaginaria). Útil en ingeniería y matemáticas avanzadas.

```python
z1 = 2 + 3j
z2 = 1 - 4j
print(z1 * z2)  # (14 - 5j)
print(abs(z1))  # módulo → 3.605...
```

---

## 🔁 3) `range`

Secuencia **inmutable** de números enteros, generalmente usada en bucles o iteraciones.

```python
for i in range(3, 10, 2):
    print(i)
# 3 5 7 9

nums = list(range(5))
print(nums)  # [0, 1, 2, 3, 4]
```

`range` no almacena todos los valores en memoria, sino que los **genera bajo demanda** (eficiencia espacial).

---

## ⚙️ 4) Datos binarios: `bytes`, `bytearray`, `memoryview`

### 🔹 `bytes`

Secuencia **inmutable** de enteros (0–255). Representa datos binarios, como archivos o comunicación en red.

```python
data = b"Hola"
print(data[0])  # 72 (código ASCII de 'H')
```

### 🔹 `bytearray`

Versión **mutable** de `bytes`. Permite modificar los valores individuales.

```python
b = bytearray(b"Hola")
b[0] = 77  # cambia 'H' (72) por 'M' (77)
print(b)  # bytearray(b'Mola')
```

### 🔹 `memoryview`

Permite acceder a una estructura binaria sin copiarla en memoria, útil para trabajar con grandes volúmenes de datos.

```python
mv = memoryview(b"Python")
print(mv[0])  # 80 (ASCII de 'P')
print(bytes(mv[2:6]))  # b'thon'
```

---

## 🧱 5) Enumeraciones: `enum`

Las **enumeraciones** permiten definir **conjuntos de valores simbólicos** con nombres legibles y controlados.

```python
from enum import Enum

class Estado(Enum):
    PENDIENTE = 1
    APROBADO = 2
    RECHAZADO = 3

print(Estado.PENDIENTE)
print(Estado.PENDIENTE.name)  # 'PENDIENTE'
print(Estado.PENDIENTE.value)  # 1
```

**Ventajas:**

* Evita el uso de números mágicos.
* Aumenta la legibilidad del código.
* Permite validaciones y comparaciones más seguras.

---

## 📊 Tabla comparativa de tipos avanzados y básicos

| Tipo         | Mutable        | Ordenado | Elementos únicos  | Uso principal                             |
| ------------ | -------------- | -------- | ----------------- | ----------------------------------------- |
| `int`        | ❌ No           | –        | –                 | Números enteros                           |
| `float`      | ❌ No           | –        | –                 | Números con decimales (punto flotante)    |
| `bool`       | ❌ No           | –        | –                 | Valores lógicos (True/False)              |
| `str`        | ❌ No           | ✅ Sí     | ❌ No              | Cadenas de texto                          |
| `list`       | ✅ Sí           | ✅ Sí     | ❌ No              | Secuencia de elementos modificable        |
| `tuple`      | ❌ No           | ✅ Sí     | ❌ No              | Secuencia inmutable                       |
| `dict`       | ✅ Sí           | ✅ Sí     | ✅ (claves únicas) | Asociación clave–valor                    |
| `set`        | ✅ Sí           | ❌ No     | ✅ Sí              | Operaciones matemáticas de conjuntos      |
| `frozenset`  | ❌ No           | ❌ No     | ✅ Sí              | Conjunto inmutable (clave de dict)        |
| `Decimal`    | ✅ Sí           | –        | –                 | Cálculos financieros con precisión exacta |
| `Fraction`   | ✅ Sí           | –        | –                 | Representación exacta de fracciones       |
| `complex`    | ❌ No           | –        | –                 | Cálculos con números complejos            |
| `range`      | ❌ No           | ✅ Sí     | ❌ No              | Secuencia numérica eficiente              |
| `bytes`      | ❌ No           | ✅ Sí     | ❌ No              | Datos binarios inmutables                 |
| `bytearray`  | ✅ Sí           | ✅ Sí     | ❌ No              | Datos binarios modificables               |
| `memoryview` | ✅ (referencia) | ✅ Sí     | ❌ No              | Acceso eficiente a datos binarios         |
| `enum`       | ❌ No           | ✅ Sí     | ✅ Sí              | Definir valores simbólicos constantes     |

---

## 🧠 Conclusión

Los **tipos de datos avanzados** amplían el alcance del lenguaje Python más allá de los tipos básicos, ofreciendo estructuras optimizadas para **precisión numérica**, **eficiencia de memoria** y **claridad semántica**.

Su uso correcto permite escribir código más **robusto, expresivo y orientado al problema**, eligiendo para cada situación la estructura de datos más adecuada.

---
