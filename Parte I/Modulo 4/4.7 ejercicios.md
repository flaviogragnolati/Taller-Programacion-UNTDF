# Módulo 4 — Estructuras de datos y algoritmos básicos

### #1 — Indexación y slicing
**Enunciado:** De nums=[3,7,1,9], imprimí el primero, el último y la suma.
**Output esperado:**
```
primero = 3
ultimo = 9
suma = 12
```

### #2 — Slicing de pares
**Enunciado:** De a=[0,1,2,3,4,5], obtené los elementos en posiciones pares.
**Output esperado:**
```
pares = [0, 2, 4]
```

### #3 — Tuplas inmutables
**Enunciado:** Convertí ['AR','CL','UY'] a tupla e intentá modificar t[1]; capturá la excepción e imprimí el nombre.
**Output esperado:**
```
excepcion = 'TypeError'
```

### #4 — Eliminar duplicados preservando orden
**Enunciado:** Dada nombres=['Ana','Luis','Ana','Mia','Luis'], quedate con la primera aparición de cada nombre (en orden).
**Output esperado:**
```
unicos = ['Ana', 'Luis', 'Mia']
```

### #5 — Operaciones con sets
**Enunciado:** Dado A={1,2,3,4} y B={3,4,5}, calculá unión, intersección y diferencia simétrica.
**Output esperado:**
```
union = {1, 2, 3, 4, 5}
interseccion = {3, 4}
diferencia_simetrica = {1, 2, 5}
```

### #6 — Frecuencias con dict
**Enunciado:** En texto='hola hola mundo mundo mundo', contá las ocurrencias por palabra.
**Output esperado:**
```
frecuencias = {'hola': 2, 'mundo': 3}
```

### #7 — Diccionario anidado
**Enunciado:** Agregá 'promedio' al dict alumno={'nombre':'Sol','legajo':123,'notas':[8,9,7]}
**Output esperado:**
```
promedio = 8.0
```

### #8 — Ordenar lista de dicts
**Enunciado:** Ordená productos por precio ascendente y devolvé el orden de nombres.
```python
productos=[{'nombre':'A','precio':20},{'nombre':'B','precio':10},{'nombre':'C','precio':15}]
```
**Output esperado:**
```
orden = ['B', 'C', 'A']
```

### #9 — Pila (stack) básica
**Enunciado:** Simulá push de 1,2,3 y un pop; mostr&aacute; tope y contenido restante.
**Output esperado:**
```
tope = 2
contenido = [1, 2]
```

### #10 — Cola (queue) con deque
**Enunciado:** Encolá 'A','B','C', desencolá uno; mostr&aacute; salido, frente y cola.
```python
from collections import deque
```
**Output esperado:**
```
salido = 'A'
frente = 'B'
cola = ["B", "C]
```

### #11 — Min-heap con prioridades
**Enunciado:** De tareas=[(3,'doc'),(1,'pagar'),(2,'mail')], extraé por prioridad (menor primero) y listá nombres.
**Output esperado:**
```
orden = ['pagar', 'mail', 'doc']
```

### #12 — Top-k con heap
**Enunciado:** De nums=[5,1,9,3,7,2], obtené los 3 mayores usando heap.
**Output esperado:**
```
top3 = [9, 7, 5]
```

### #13 — Grafo no dirigido (grados)
**Enunciado:** Para el grafo {'A':{'B','C'},'B':{'A','C'},'C':{'A','B','D'},'D':{'C'}}, calculá el grado de cada nodo.
**Output esperado:**
```
grados = {'A': 2, 'B': 2, 'C': 3, 'D': 1}
```

### #14 — BFS iterativo
**Enunciado:** Recorré el grafo del ejercicio anterior desde 'A' con BFS y listá el orden visitado.
**Output esperado:**
```
orden = ["A", "B", "C", "D]
```

### #15 — DFS iterativo — ¿hay camino?
**Enunciado:** Determiná si hay camino entre 'A' y 'D' en el grafo anterior.
**Output esperado:**
```
existe_camino = True
```

### #16 — Árbol: recorrido in-order (lista)
**Enunciado:** Dado el árbol binario como tuplas anidadas (valor, izq, der) = (2, (1,None,None), (3,None,None)), devolvé el in-order.
```python
arbol = (2, (1, None, None), (3, None, None))
```
**Output esperado:**
```
inorder = [1, 2, 3]
```

### #17 — map básico
**Enunciado:** Multiplicá por 2 cada elemento de [1,2,3] usando map.
**Output esperado:**
```
resultado = [2, 4, 6]
```

### #18 — filter básico
**Enunciado:** Filtrá los pares de range(10) usando filter.
**Output esperado:**
```
pares = [0, 2, 4, 6, 8]
```

### #19 — reduce suma
**Enunciado:** Sumá [1,2,3,4] con functools.reduce.
**Output esperado:**
```
suma = 10
```

### #20 — Composición map+filter
**Enunciado:** De [1,2,3,4,5], obtené cuadrados de los impares.
**Output esperado:**
```
resultado = [1, 9, 25]
```

### #21 — iter() y next()
**Enunciado:** Consumí un iterador sobre ['a','b'] e imprimí elementos hasta StopIteration, luego 'fin'.
**Output esperado:**
```
linea1 = 'a'
linea2 = 'b'
linea3 = 'fin'
```

### #22 — Generador simple
**Enunciado:** Definí cuenta(n) que rinda 0..n-1; listá cuenta(4).
**Output esperado:**
```
salida = [0, 1, 2, 3]
```

### #23 — Generador Fibonacci
**Enunciado:** Generá los primeros 6 números de Fibonacci.
**Output esperado:**
```
serie = [0, 1, 1, 2, 3, 5]
```

### #24 — yield from (flatten)
**Enunciado:** Combiná sublistas con yield from: [[1,2],[3],[4,5]].
**Output esperado:**
```
flatten = [1, 2, 3, 4, 5]
```

### #25 — Recursión — factorial
**Enunciado:** Calculá factorial(6) de forma recursiva.
**Output esperado:**
```
resultado = 720
```

### #26 — Recursión — suma de lista
**Enunciado:** Sumá recursivamente [1,2,3,4].
**Output esperado:**
```
suma = 10
```

### #27 — IIFE en Python (func inmediata)
**Enunciado:** Ejecutá inmediatamente una función anónima que devuelva 'ok'.
> **Tip:** Usá (lambda: 'ok')()
**Output esperado:**
```
resultado = 'ok'
```

### #28 — Currying con closures
**Enunciado:** Implementá un generador de sumadores: suma_a(5)(3) -> 8.
**Output esperado:**
```
valor = 8
```

### #29 — Recursión — potencia rápida
**Enunciado:** Implementá potencia(a,b) por exponenciación binaria (divide y vencerás) y calculá 2^10.
**Output esperado:**
```
resultado = 1024
```

### #30 — Mutua recursión (par/impar)
**Enunciado:** Implementá es_par(n) y es_impar(n) recursivos para n=7.
**Output esperado:**
```
es_par = False
es_impar = True
```

### #31 — Búsqueda lineal
**Enunciado:** Buscá 7 en [1,4,7,9] devolviendo el índice o -1.
**Output esperado:**
```
indice = 2
```

### #32 — Búsqueda binaria
**Enunciado:** En [1,3,5,7,9], buscá 7 y devolvé su índice.
**Output esperado:**
```
indice = 3
```

### #33 — Ordenamiento por selección
**Enunciado:** Ordená [3,1,4,2] con selección (resultado final).
**Output esperado:**
```
ordenado = [1, 2, 3, 4]
```

### #34 — Ordenamiento por inserción
**Enunciado:** Ordená [5,2,4,6,1,3] con inserción (resultado final).
**Output esperado:**
```
ordenado = [1, 2, 3, 4, 5, 6]
```

### #35 — Merge sort (salida final)
**Enunciado:** Ordená [9,1,8,3,7,2,6,4,5] usando merge sort.
**Output esperado:**
```
ordenado = [1, 2, 3, 4, 5, 6, 7, 8, 9]
```

### #36 — Quick sort (salida final)
**Enunciado:** Ordená [10,7,8,9,1,5] usando quick sort (Lomuto/Hoare, resultado final).
**Output esperado:**
```
ordenado = [1, 5, 7, 8, 9, 10]
```

### #37 — Big O — Conteo anidado
**Enunciado:** Para un doble bucle hasta n, indicá la complejidad asintótica.
**Output esperado:**
```
complejidad = 'O(n^2)'
```

### #38 — Big O — Búsqueda binaria
**Enunciado:** Indicá la complejidad temporal de la búsqueda binaria.
**Output esperado:**
```
complejidad = 'O(log n)'
```

### #39 — Memoria — lista vs generador
**Enunciado:** Para generar 1..10^6, indicá cuál usa menos memoria y por qué (lista vs generador).
**Output esperado:**
```
recomendacion = 'generador'
```

### #40 — Rendimiento — evita concatenar strings en loop
**Enunciado:** Indicá la práctica recomendada para unir muchas cadenas.
**Output esperado:**
```
recomendacion = "usar ' '.join(...)"
```

### #41 — Integrador — Normalizar, contar y ordenar
**Enunciado:** Dada una lista de palabras con mayúsculas/minúsculas y espacios extra, normalizá (lower, strip), contá frecuencias y mostr&aacute; top-3 por frecuencia (alfabético para empates).
```python
palabras = ['  Python', 'data', 'ML', 'python ', 'Data', 'ml', 'data', 'PYTHON']
```
**Output esperado:**
```
top3 = [('data', 3), ('ml', 2), ('python', 2)]
```

### #42 — Integrador — Grafo y BFS por niveles
**Enunciado:** Construí un grafo simple y devolvé una lista de niveles (nodos por distancia) desde 'A'.
```python
grafo = {'A':{'B','C'}, 'B':{'A','D'}, 'C':{'A','D'}, 'D':{'B','C'}}
```
**Output esperado:**
```
niveles = [['A'], ['B', 'C'], ['D']]
```

### #43 — Integrador — Ruta más corta (no ponderado)
**Enunciado:** En el grafo del ejercicio anterior, devolvé el camino más corto de 'A' a 'D'.
**Output esperado:**
```
camino = ["A", "B", "D]
```

### #44 — Integrador — Heap y tareas dependientes
**Enunciado:** Dado un mapa de dependencias (A→C, B→C, C→D) y prioridades A:2,B:1,C:3,D:1, generá un orden válido usando heap para elegir la siguiente tarea disponible (menor prioridad primero).
**Output esperado:**
```
orden = ["B", "A", "C", "D]
```

### #45 — Integrador — Generadores encadenados
**Enunciado:** Con generadores, filtrá números de 1..100 que sean cuadrados perfectos y pares; devolvé la lista.
**Output esperado:**
```
resultado = [4, 16, 36, 64, 100]
```

### #46 — Integrador — Currying + map/filter
**Enunciado:** Usá currying para crear una función que sume un valor a cada elemento y luego filtrá los que quedan múltiplos de 5 en [1,2,3,4,5].
**Output esperado:**
```
resultado = [5, 10]
```

### #47 — Integrador — Ordenamientos comparados
**Enunciado:** Mostrá que sorted() y tu implementación de merge sort producen el mismo resultado para [9,3,1,5,13,12].
**Output esperado:**
```
igual = True
```

### #48 — Integrador — Búsqueda en datos
**Enunciado:** Dada una lista ordenada de tuplas (id,nombre), buscá binariamente id=42 y devolvé el nombre.
```python
datos = [(1,'Ana'),(7,'Luis'),(19,'Mia'),(42,'Sol'),(77,'Leo')]
```
**Output esperado:**
```
nombre = 'Sol'
```

### #49 — Integrador — Árbol binario: altura y conteo
**Enunciado:** Para el árbol (5,(3,(2,None,None),(4,None,None)),(7,(6,None,None),(8,None,None))) calculá altura y cantidad de nodos.
```python
arbol = (5,(3,(2,None,None),(4,None,None)),(7,(6,None,None),(8,None,None)))
```
**Output esperado:**
```
altura = 3
nodos = 7
```

### #50 — Integrador — Streaming y rendimiento
**Enunciado:** Procesá un archivo simulado línea por línea con un generador, filtrá líneas que contienen 'ERROR' y contalas. Evitá cargar todo en memoria.
```python
lineas = ['INFO ok','WARN x','ERROR fallo 1','DEBUG t','ERROR fallo 2']
```
**Output esperado:**
```
errores = 2
```


---

### Desafío A — Ranking de productos por ventas
**Enunciado:** Dado un listado de ventas diarias (producto, cantidad), calculá el top-5 de productos por cantidad total vendida. En caso de empate, ordenar alfabéticamente. Usar estructuras adecuadas (dict, heap opcional).

```python
# Datos de entrada
ventas = [
    ("A", 3), ("B", 5), ("A", 7), ("C", 2), ("B", 1),
    ("D", 4), ("E", 6), ("C", 5), ("D", 1), ("E", 2),
    ("F", 9), ("A", 2), ("B", 3), ("E", 1), ("C", 3)
]
k = 5  # top-k
```

**Output esperado:**
```
top_k = [('A', 12), ('B', 9), ('E', 9), ('C', 10), ('F', 9)]
```

### Desafío B — Camino válido con restricciones
**Enunciado:** Dado un grafo no dirigido y un conjunto de nodos prohibidos, determiná si existe un camino entre origen y destino evitando nodos prohibidos. Si existe, devolvé un camino válido de longitud mínima (BFS).

```python
# Datos de entrada
grafo = {
    "A": {"B", "C"},
    "B": {"A", "D"},
    "C": {"A", "D", "E"},
    "D": {"B", "C", "F"},
    "E": {"C"},
    "F": {"D"}
}
origen = "A"
destino = "F"
prohibidos = {"E"}
```

**Output esperado:**
```
existe = True
camino = ['A', 'B', 'D', 'F']
```
