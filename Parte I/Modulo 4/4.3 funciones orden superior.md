# ğŸ§© MÃ³dulo 4: Estructuras de Datos y Algoritmos BÃ¡sicos

## **Tema 4.3: Funciones de Orden Superior, Iteradores y Generadores**

---

### ğŸ§  IntroducciÃ³n

En este tema exploraremos tres conceptos fundamentales de la programaciÃ³n moderna en Python:
**las funciones de orden superior**, **los iteradores** y **los generadores**.

Estas herramientas permiten escribir cÃ³digo mÃ¡s **declarativo, reutilizable y eficiente**, especialmente cuando trabajamos con grandes volÃºmenes de datos o flujos que no necesitan almacenarse completamente en memoria.

---

## ğŸ”¹ 1. Funciones de Orden Superior

Una **funciÃ³n de orden superior** es aquella que puede **recibir otras funciones como argumento** y/o **devolver una funciÃ³n como resultado**.

En Python, las funciones son **ciudadanos de primera clase** (*first-class citizens*), lo que significa que pueden:
- Asignarse a variables,
- Pasarse como parÃ¡metros,
- Retornarse desde otras funciones.

### ğŸ“˜ Ejemplo 1: FunciÃ³n como parÃ¡metro

```python
def aplicar_operacion(funcion, numeros):
    resultado = []
    for n in numeros:
        resultado.append(funcion(n))
    return resultado

def cuadrado(x):
    return x ** 2

valores = [1, 2, 3, 4]
print(aplicar_operacion(cuadrado, valores))  # [1, 4, 9, 16]
```

### ğŸ“˜ Ejemplo 2: FunciÃ³n que devuelve otra funciÃ³n

```python
def crear_multiplicador(factor):
    def multiplicar(x):
        return x * factor
    return multiplicar

duplicar = crear_multiplicador(2)
triplicar = crear_multiplicador(3)

print(duplicar(5))   # 10
print(triplicar(5))  # 15
```

---

## ğŸ”¹ 2. Funciones integradas: `map()`, `filter()`, `reduce()`

Python incluye varias funciones de orden superior ya integradas que permiten procesar colecciones de manera funcional:

| FunciÃ³n | DescripciÃ³n | Ejemplo de uso |
|----------|--------------|----------------|
| `map(func, iterable)` | Aplica una funciÃ³n a cada elemento | `map(lambda x: x**2, datos)` |
| `filter(func, iterable)` | Filtra elementos segÃºn una condiciÃ³n | `filter(lambda x: x > 0, datos)` |
| `reduce(func, iterable)` | Aplica una funciÃ³n acumulativa sobre los elementos | `reduce(lambda x, y: x + y, datos)` |

> `reduce()` se encuentra en el mÃ³dulo `functools`.

---

### ğŸ§© Ejemplo prÃ¡ctico: procesamiento de una lista de datos

Supongamos que tenemos una lista con temperaturas en grados Celsius y queremos:
1. Convertirlas a Fahrenheit,
2. Filtrar solo las mayores a 80Â°F,
3. Calcular el promedio de esas temperaturas filtradas.

```python
from functools import reduce

temperaturas_celsius = [10, 15, 22, 30, 35, 40]

# 1ï¸âƒ£ Convertir a Fahrenheit (map)
temperaturas_f = list(map(lambda c: c * 9/5 + 32, temperaturas_celsius))
print("Temperaturas en Fahrenheit:", temperaturas_f)

# 2ï¸âƒ£ Filtrar mayores a 80Â°F (filter)
altas = list(filter(lambda f: f > 80, temperaturas_f))
print("Temperaturas altas (>80Â°F):", altas)

# 3ï¸âƒ£ Calcular el promedio (reduce)
if altas:
    promedio = reduce(lambda a, b: a + b, altas) / len(altas)
    print("Promedio de temperaturas altas:", round(promedio, 2))
else:
    print("No hay temperaturas mayores a 80Â°F.")
```

ğŸ“¤ **Salida esperada:**
```
Temperaturas en Fahrenheit: [50.0, 59.0, 71.6, 86.0, 95.0, 104.0]
Temperaturas altas (>80Â°F): [86.0, 95.0, 104.0]
Promedio de temperaturas altas: 95.0
```

### ğŸ’¡ Observaciones
- `map()` transforma los datos.
- `filter()` selecciona un subconjunto.
- `reduce()` resume la secuencia a un Ãºnico valor.
- Este patrÃ³n es muy comÃºn en **anÃ¡lisis de datos, procesamiento funcional y pipelines**.

---

## ğŸ”¹ 3. Iteradores

Un **iterador** es un objeto que **recorre secuencias de datos** (listas, tuplas, cadenas, etc.) **uno a la vez**, recordando su posiciÃ³n actual.

Python implementa el protocolo de iteraciÃ³n mediante dos mÃ©todos especiales:
- `__iter__()` â†’ devuelve el propio iterador.
- `__next__()` â†’ devuelve el siguiente elemento o lanza `StopIteration` al finalizar.

### ğŸ“˜ Ejemplo bÃ¡sico:

```python
numeros = [10, 20, 30]
it = iter(numeros)

print(next(it))  # 10
print(next(it))  # 20
print(next(it))  # 30
# next(it) -> StopIteration
```

### ğŸ“˜ Ejemplo de iterador personalizado:

```python
class Contador:
    def __init__(self, inicio, fin):
        self.actual = inicio
        self.fin = fin

    def __iter__(self):
        return self

    def __next__(self):
        if self.actual > self.fin:
            raise StopIteration
        valor = self.actual
        self.actual += 1
        return valor


for n in Contador(1, 5):
    print(n, end=" ")
# Salida: 1 2 3 4 5
```

---

## ğŸ”¹ 4. Generadores

Los **generadores** son una forma mÃ¡s sencilla y eficiente de crear iteradores en Python.  
En lugar de definir las clases `__iter__` y `__next__`, un generador se construye con la palabra clave `yield`.

Cada vez que una funciÃ³n generadora llama a `yield`, **pausa su ejecuciÃ³n** y **devuelve un valor**.  
Al reanudar, continÃºa desde donde se detuvo.

### ğŸ“˜ Ejemplo 1: Generador simple

```python
def contar_hasta(n):
    contador = 1
    while contador <= n:
        yield contador
        contador += 1

for numero in contar_hasta(5):
    print(numero)
```

ğŸ“¤ **Salida:**
```
1
2
3
4
5
```

---

## ğŸ”¹ 5. Expresiones generadoras

Son una **versiÃ³n compacta** de los generadores, similares a las listas por comprensiÃ³n pero usando `()` en lugar de `[]`.

```python
# Lista por comprensiÃ³n
cuadrados_lista = [x**2 for x in range(5)]

# Generador equivalente
cuadrados_gen = (x**2 for x in range(5))

for n in cuadrados_gen:
    print(n)
```

---

## ğŸ”¹ 6. Uso combinado: funciones de orden superior + generadores

Los generadores pueden combinarse con funciones de orden superior para construir **pipelines de datos** eficientes.

```python
def filtrar_pares(numeros):
    for n in numeros:
        if n % 2 == 0:
            yield n

def elevar_al_cuadrado(numeros):
    for n in numeros:
        yield n ** 2

# ComposiciÃ³n
datos = range(10)
resultado = elevar_al_cuadrado(filtrar_pares(datos))

for valor in resultado:
    print(valor)
```

ğŸ“¤ **Salida:**
```
0
4
16
36
64
```

---

## ğŸ“š Resumen

| Concepto | DescripciÃ³n | Palabras clave / Funciones | Ejemplo tÃ­pico |
|-----------|--------------|----------------------------|----------------|
| **FunciÃ³n de orden superior** | Recibe o devuelve funciones | `map`, `filter`, `sorted`, `reduce` | `map(lambda x: x*2, datos)` |
| **Iterador** | Objeto que recorre una secuencia paso a paso | `iter()`, `next()` | `for x in iter(obj)` |
| **Generador** | FunciÃ³n que produce valores bajo demanda | `yield`, `(expr for x in iterable)` | `yield x**2` |

---

## ğŸ“– Recursos y referencias

- *Python Documentation â€“ Iterators & Generators*: [https://docs.python.org/3/tutorial/classes.html#iterators](https://docs.python.org/3/tutorial/classes.html#iterators)
- *PEP 255 â€“ Simple Generators in Python*
- *Luciano Ramalho â€“ Fluent Python* (Oâ€™Reilly, 2022)
- *Think Python* â€“ Allen B. Downey
- *Real Python Tutorials* â€“ [https://realpython.com/](https://realpython.com/)

---
