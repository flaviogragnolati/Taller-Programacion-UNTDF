# 🧩 Módulo 4: Estructuras de Datos y Algoritmos Básicos

## **Tema 4.3: Funciones de Orden Superior, Iteradores y Generadores**

---

### 🧠 Introducción

En este tema exploraremos tres conceptos fundamentales de la programación moderna en Python:
**las funciones de orden superior**, **los iteradores** y **los generadores**.

Estas herramientas permiten escribir código más **declarativo, reutilizable y eficiente**, especialmente cuando trabajamos con grandes volúmenes de datos o flujos que no necesitan almacenarse completamente en memoria.

---

## 🔹 1. Funciones de Orden Superior

Una **función de orden superior** es aquella que puede **recibir otras funciones como argumento** y/o **devolver una función como resultado**.

En Python, las funciones son **ciudadanos de primera clase** (*first-class citizens*), lo que significa que pueden:
- Asignarse a variables,
- Pasarse como parámetros,
- Retornarse desde otras funciones.

### 📘 Ejemplo 1: Función como parámetro

```python
def aplicar_operacion(funcion, numeros):
    resultado = []
    for n in numeros:
        resultado.append(funcion(n))
    return resultado

def cuadrado(x):
    return x ** 2

valores = [1, 2, 3, 4]
print(aplicar_operacion(cuadrado, valores))  # [1, 4, 9, 16]
```

### 📘 Ejemplo 2: Función que devuelve otra función

```python
def crear_multiplicador(factor):
    def multiplicar(x):
        return x * factor
    return multiplicar

duplicar = crear_multiplicador(2)
triplicar = crear_multiplicador(3)

print(duplicar(5))   # 10
print(triplicar(5))  # 15
```

---

## 🔹 2. Funciones integradas: `map()`, `filter()`, `reduce()`

Python incluye varias funciones de orden superior ya integradas que permiten procesar colecciones de manera funcional:

| Función | Descripción | Ejemplo de uso |
|----------|--------------|----------------|
| `map(func, iterable)` | Aplica una función a cada elemento | `map(lambda x: x**2, datos)` |
| `filter(func, iterable)` | Filtra elementos según una condición | `filter(lambda x: x > 0, datos)` |
| `reduce(func, iterable)` | Aplica una función acumulativa sobre los elementos | `reduce(lambda x, y: x + y, datos)` |

> `reduce()` se encuentra en el módulo `functools`.

---

### 🧩 Ejemplo práctico: procesamiento de una lista de datos

Supongamos que tenemos una lista con temperaturas en grados Celsius y queremos:
1. Convertirlas a Fahrenheit,
2. Filtrar solo las mayores a 80°F,
3. Calcular el promedio de esas temperaturas filtradas.

```python
from functools import reduce

temperaturas_celsius = [10, 15, 22, 30, 35, 40]

# 1️⃣ Convertir a Fahrenheit (map)
temperaturas_f = list(map(lambda c: c * 9/5 + 32, temperaturas_celsius))
print("Temperaturas en Fahrenheit:", temperaturas_f)

# 2️⃣ Filtrar mayores a 80°F (filter)
altas = list(filter(lambda f: f > 80, temperaturas_f))
print("Temperaturas altas (>80°F):", altas)

# 3️⃣ Calcular el promedio (reduce)
if altas:
    promedio = reduce(lambda a, b: a + b, altas) / len(altas)
    print("Promedio de temperaturas altas:", round(promedio, 2))
else:
    print("No hay temperaturas mayores a 80°F.")
```

📤 **Salida esperada:**
```
Temperaturas en Fahrenheit: [50.0, 59.0, 71.6, 86.0, 95.0, 104.0]
Temperaturas altas (>80°F): [86.0, 95.0, 104.0]
Promedio de temperaturas altas: 95.0
```

### 💡 Observaciones
- `map()` transforma los datos.
- `filter()` selecciona un subconjunto.
- `reduce()` resume la secuencia a un único valor.
- Este patrón es muy común en **análisis de datos, procesamiento funcional y pipelines**.

---

## 🔹 3. Iteradores

Un **iterador** es un objeto que **recorre secuencias de datos** (listas, tuplas, cadenas, etc.) **uno a la vez**, recordando su posición actual.

Python implementa el protocolo de iteración mediante dos métodos especiales:
- `__iter__()` → devuelve el propio iterador.
- `__next__()` → devuelve el siguiente elemento o lanza `StopIteration` al finalizar.

### 📘 Ejemplo básico:

```python
numeros = [10, 20, 30]
it = iter(numeros)

print(next(it))  # 10
print(next(it))  # 20
print(next(it))  # 30
# next(it) -> StopIteration
```

### 📘 Ejemplo de iterador personalizado:

```python
class Contador:
    def __init__(self, inicio, fin):
        self.actual = inicio
        self.fin = fin

    def __iter__(self):
        return self

    def __next__(self):
        if self.actual > self.fin:
            raise StopIteration
        valor = self.actual
        self.actual += 1
        return valor


for n in Contador(1, 5):
    print(n, end=" ")
# Salida: 1 2 3 4 5
```

---

## 🔹 4. Generadores

Los **generadores** son una forma más sencilla y eficiente de crear iteradores en Python.  
En lugar de definir las clases `__iter__` y `__next__`, un generador se construye con la palabra clave `yield`.

Cada vez que una función generadora llama a `yield`, **pausa su ejecución** y **devuelve un valor**.  
Al reanudar, continúa desde donde se detuvo.

### 📘 Ejemplo 1: Generador simple

```python
def contar_hasta(n):
    contador = 1
    while contador <= n:
        yield contador
        contador += 1

for numero in contar_hasta(5):
    print(numero)
```

📤 **Salida:**
```
1
2
3
4
5
```

---

## 🔹 5. Expresiones generadoras

Son una **versión compacta** de los generadores, similares a las listas por comprensión pero usando `()` en lugar de `[]`.

```python
# Lista por comprensión
cuadrados_lista = [x**2 for x in range(5)]

# Generador equivalente
cuadrados_gen = (x**2 for x in range(5))

for n in cuadrados_gen:
    print(n)
```

---

## 🔹 6. Uso combinado: funciones de orden superior + generadores

Los generadores pueden combinarse con funciones de orden superior para construir **pipelines de datos** eficientes.

```python
def filtrar_pares(numeros):
    for n in numeros:
        if n % 2 == 0:
            yield n

def elevar_al_cuadrado(numeros):
    for n in numeros:
        yield n ** 2

# Composición
datos = range(10)
resultado = elevar_al_cuadrado(filtrar_pares(datos))

for valor in resultado:
    print(valor)
```

📤 **Salida:**
```
0
4
16
36
64
```

---

## 📚 Resumen

| Concepto | Descripción | Palabras clave / Funciones | Ejemplo típico |
|-----------|--------------|----------------------------|----------------|
| **Función de orden superior** | Recibe o devuelve funciones | `map`, `filter`, `sorted`, `reduce` | `map(lambda x: x*2, datos)` |
| **Iterador** | Objeto que recorre una secuencia paso a paso | `iter()`, `next()` | `for x in iter(obj)` |
| **Generador** | Función que produce valores bajo demanda | `yield`, `(expr for x in iterable)` | `yield x**2` |

---

## 📖 Recursos y referencias

- *Python Documentation – Iterators & Generators*: [https://docs.python.org/3/tutorial/classes.html#iterators](https://docs.python.org/3/tutorial/classes.html#iterators)
- *PEP 255 – Simple Generators in Python*
- *Luciano Ramalho – Fluent Python* (O’Reilly, 2022)
- *Think Python* – Allen B. Downey
- *Real Python Tutorials* – [https://realpython.com/](https://realpython.com/)

---
