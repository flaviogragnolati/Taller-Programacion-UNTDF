# üß© M√≥dulo 4: Estructuras de Datos y Algoritmos B√°sicos

## **Tema 4.3.1: Funciones *built-in* √∫tiles de Python**

En este apunte vemos algunas funciones *built-in* de Python que aparecen todo el tiempo cuando exploramos objetos, trabajamos con colecciones o queremos entender mejor qu√© est√° pasando ‚Äúpor debajo del cap√≥‚Äù del lenguaje:

- `dir`
- `all`
- `any`
- `zip`
- `iter`
- `slice`
- `type`
- `vars`

---

## 1. `dir()`

`dir(obj)` devuelve una **lista de nombres de atributos** (m√©todos, propiedades, etc.) asociados a un objeto.

### üß† ¬øPara qu√© sirve?

- Explorar **qu√© tiene** un objeto (m√©todos, atributos).
- Investigar r√°pidamente una librer√≠a o un m√≥dulo.
- Ver qu√© atributos especiales (`__dunder__`) est√°n definidos.

> Si se llama sin argumentos (`dir()`), devuelve los nombres definidos en el **√°mbito actual** (variables locales).

### ‚ö†Ô∏è Caveats

- No siempre lista **absolutamente todo**: las clases pueden redefinir `__dir__`.
- El orden de la lista **no est√° garantizado** (aunque suele venir ordenada alfab√©ticamente).
- En objetos que implementan `__getattr__` din√°mico, `dir()` puede no reflejar todo lo que ‚Äúparece‚Äù tener el objeto.

### üíª Ejemplo

```python
x = 42
print(dir(x))  # Atributos y m√©todos del int

import math
print(dir(math))  # Funciones y constantes del m√≥dulo math

# Sin argumentos: nombres en el √°mbito actual
a = 10
b = 20
print(dir())
```

---

## 2. `all()`

`all(iterable)` devuelve `True` si **todos** los elementos del iterable son *truthy* (es decir, se eval√∫an como verdaderos), o si el iterable est√° **vac√≠o**.

### üß† ¬øPara qu√© sirve?

- Verificar que **todas las condiciones** se cumplen.
- Componer chequeos l√≥gicos sobre listas/tuplas/comprehensions.
- Validar datos: ‚Äú¬øtodos los campos est√°n completos?‚Äù, ‚Äú¬øtodas las mediciones son positivas?‚Äù, etc.

### ‚ö†Ô∏è Caveats

- `all([])` es `True` (esto suele sorprender). Conceptualmente: ‚Äúno hay contraejemplos‚Äù.
- Cuenta la ‚Äúverdad‚Äù seg√∫n la sem√°ntica de Python: `0`, `''`, `None`, `[]`, `{}` ‚Üí *falsy*.

### üíª Ejemplo

```python
edades = [22, 35, 19, 40]
print(all(e > 18 for e in edades))  # True

valores = [1, 2, 0, 4]
print(all(valores))  # False (porque hay un 0)

print(all([]))       # True (no hay ning√∫n elemento falso)
```

---

## 3. `any()`

`any(iterable)` devuelve `True` si **al menos uno** de los elementos del iterable es *truthy*. Devuelve `False` si el iterable est√° vac√≠o o todos los elementos son falsos.

### üß† ¬øPara qu√© sirve?

- Verificar si **al menos una condici√≥n** se cumple.
- Chequear presencia de un valor que cumpla algo en una colecci√≥n.
- Validar r√°pidamente: ‚Äú¬øhay alg√∫n error?‚Äù, ‚Äú¬øhay alg√∫n valor fuera de rango?‚Äù, etc.

### ‚ö†Ô∏è Caveats

- `any([])` es `False`.
- Igual que `all`, usa la sem√°ntica de verdad de Python.

### üíª Ejemplo

```python
temperaturas = [-5, -3, 0, 2, 10]
print(any(t > 0 for t in temperaturas))  # True

errores = [False, False, False]
print(any(errores))  # False

print(any([]))       # False
```

---

## 4. `zip()`

`zip(*iterables)` agrupa varios iterables ‚Äúen paralelo‚Äù, devolviendo un iterator de tuplas donde la i-√©sima tupla contiene el i-√©simo elemento de cada iterable.

### üß† ¬øPara qu√© sirve?

- ‚ÄúEmparejar‚Äù listas: nombres con edades, claves con valores, etc.
- Iterar en paralelo sobre varias colecciones.
- ‚ÄúDesemparejar‚Äù (unzip) listas de tuplas.

> Se detiene cuando **el iterable m√°s corto** se queda sin elementos.

### ‚ö†Ô∏è Caveats

- En Python 3, `zip()` devuelve un **iterador**, no una lista. Si quer√©s una lista, us√° `list(zip(...))`.
- Si las listas tienen distinta longitud, se pierden los elementos ‚Äúsobrantes‚Äù del m√°s largo.

### üíª Ejemplos

```python
nombres = ["Ana", "Juan", "Luc√≠a"]
edades = [25, 30, 22]

for nombre, edad in zip(nombres, edades):
    print(nombre, "tiene", edad, "a√±os")

# Construir un diccionario a partir de dos listas
d = dict(zip(nombres, edades))
print(d)  # {'Ana': 25, 'Juan': 30, 'Luc√≠a': 22}

# "Desempaquetar" (unzip)
pares = list(zip(nombres, edades))
nombres2, edades2 = zip(*pares)
print(nombres2)  # ('Ana', 'Juan', 'Luc√≠a')
print(edades2)   # (25, 30, 22)
```

---

## 5. `iter()`

`iter(obj)` devuelve un **iterador** a partir de un objeto iterable (listas, tuplas, strings, etc.).

Tambi√©n existe la forma `iter(func, sentinel)`, que crea un iterador llamando repetidamente a `func()` hasta que el resultado sea igual a `sentinel`.

### üß† ¬øPara qu√© sirve?

- Obtener expl√≠citamente el iterador de una colecci√≥n.
- Implementar bucles manuales con `next()` (aunque lo usual es usar `for`).
- Usar el patr√≥n `iter(func, sentinel)` para leer datos hasta una condici√≥n de corte.

### ‚ö†Ô∏è Caveats

- Un **iterador se consume**: una vez que lo recorr√©s, no se puede reutilizar sin recrearlo.
- Muchos principiantes esperan que un iterador se ‚Äúresetee‚Äù, pero no es as√≠.

### üíª Ejemplos

```python
nums = [10, 20, 30]
it = iter(nums)

print(next(it))  # 10
print(next(it))  # 20
print(next(it))  # 30
# print(next(it))  # StopIteration

# iter(func, sentinel)
import sys

def leer_linea():
    return sys.stdin.readline().strip()

for linea in iter(leer_linea, "FIN"):
    print("Le√≠do:", linea)
```

---

## 6. `slice()`

`slice(start, stop[, step])` crea un **objeto de corte** que representa un rango de √≠ndices. Es la versi√≥n ‚Äúprogram√°tica‚Äù de la notaci√≥n `obj[start:stop:step]`.

### üß† ¬øPara qu√© sirve?

- Cuando queremos **reutilizar** el mismo slice en distintos lugares.
- Para pasar rangos de √≠ndices como objeto (por ejemplo, en funciones gen√©ricas).
- Para trabajar con cortes complejos sin ‚Äúquemar‚Äù la sintaxis literal.

### ‚ö†Ô∏è Caveats

- Muy usado internamente; en c√≥digo cotidiano normalmente vemos m√°s la sintaxis `[:]`.
- `start` puede ser `None`, lo mismo que `stop` o `step`.

### üíª Ejemplos

```python
texto = "Ingenier√≠a"
# Sintaxis habitual
print(texto[0:4])  # "Inge"

# Usando slice()
s = slice(0, 4)
print(texto[s])    # "Inge"

# Slice con step
s2 = slice(None, None, 2)  # desde el inicio al final, de a 2
print(texto[s2])
```

---

## 7. `type()`

`type(obj)` devuelve el **tipo** (la clase) de un objeto.

Tambi√©n existe la forma avanzada `type(name, bases, dict)` que permite **crear clases din√°micamente**, pero eso suele ser menos frecuente en c√≥digo introductorio.

### üß† ¬øPara qu√© sirve?

- Inspeccionar el tipo de una variable u objeto.
- Depurar c√≥digo: entender qu√© tipo llega a una funci√≥n.
- En contextos r√°pidos / exploratorios (logging, debugging, REPL).

### ‚ö†Ô∏è Caveats

- Para chequeos de tipo, en general es mejor usar `isinstance(obj, Clase)` que `type(obj) is Clase`, porque `isinstance` respeta herencia.
- El resultado de `type()` es un objeto clase, no un string.

### üíª Ejemplos

```python
x = 3.14
print(type(x))  # <class 'float'>

texto = "hola"
print(type(texto))  # <class 'str'>

# Chequeos: mejor isinstance
class Animal:
    ...

class Perro(Animal):
    ...

p = Perro()
print(type(p) is Animal)      # False
print(isinstance(p, Animal))  # True
```

---

## 8. `vars()`

`vars(obj)` devuelve el **diccionario de atributos** (`__dict__`) de un objeto que lo tenga (instancias, m√≥dulos, algunos tipos de clases).

Sin argumentos (`vars()`), se comporta de forma similar a `locals()` en algunos contextos (pero no se recomienda depender de eso demasiado).

### üß† ¬øPara qu√© sirve?

- Inspeccionar r√°pidamente el **estado interno** de una instancia (sus atributos).
- Ver qu√© variables existen en un m√≥dulo.
- Serializar objetos simples (cuando sus atributos son b√°sicos).

### ‚ö†Ô∏è Caveats

- No todos los objetos tienen `__dict__`; algunos usan `__slots__` y no funcionan con `vars()`.
- Modificar el diccionario devuelto puede cambiar el objeto, pero hay que hacerlo con cuidado (no siempre es buena pr√°ctica).

### üíª Ejemplos

```python
class Persona:
    def __init__(self, nombre, edad):
        self.nombre = nombre
        self.edad = edad

p = Persona("Ana", 28)
print(vars(p))  # {'nombre': 'Ana', 'edad': 28}

import math
print(list(vars(math).keys())[:5])  # Algunos nombres del m√≥dulo math

# Sin argumentos (no depender demasiado de esto)
a = 10
b = 20
print(vars())  # Variables locales (en este √°mbito)
```

---

## üßæ Resumen r√°pido

| Funci√≥n | ¬øQu√© hace? | Usos t√≠picos |
|--------|-------------|-------------|
| `dir(obj)` | Lista nombres de atributos/m√©todos de un objeto | Exploraci√≥n, debugging, entender APIs |
| `all(iterable)` | `True` si todos los elementos son *truthy* o si est√° vac√≠o | Validar que ‚Äútodo est√° OK‚Äù |
| `any(iterable)` | `True` si al menos un elemento es *truthy* | Detectar si ‚Äúhay al menos un caso‚Äù |
| `zip(*iterables)` | Agrupa elementos en paralelo en tuplas | Recorrer listas en paralelo, crear diccionarios |
| `iter(obj)` | Crea un iterador desde un iterable | Uso con `next`, patrones especiales de lectura |
| `slice(start, stop, step)` | Representa un rango de √≠ndices | Reutilizar cortes, funciones gen√©ricas |
| `type(obj)` | Devuelve la clase del objeto | Inspecci√≥n de tipos, debugging r√°pido |
| `vars(obj)` | Devuelve el `__dict__` de un objeto | Ver estado interno, inspeccionar m√≥dulos |
