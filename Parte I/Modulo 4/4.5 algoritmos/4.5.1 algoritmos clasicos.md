# 游빌 M칩dulo 4: Estructuras de Datos y Algoritmos B치sicos
## **Tema 4.6: Algoritmos Cl치sicos y Modernos**

---

### 游 Introducci칩n General

Los algoritmos son el n칰cleo de toda ciencia de la computaci칩n. Desde los tiempos de Euclides hasta la inteligencia artificial moderna, representan el conjunto de pasos definidos que permiten resolver un problema o transformar datos en informaci칩n 칰til.
A lo largo de la historia, los algoritmos han evolucionado desde simples m칠todos matem치ticos hasta sistemas complejos que gobiernan la comunicaci칩n, la optimizaci칩n industrial y el aprendizaje autom치tico.

En este apunte exploraremos los **principales algoritmos cl치sicos y modernos**, comprendiendo su objetivo, fundamento te칩rico, origen y ejemplo en Python.

---

## 游빑 1. Algoritmos Fundamentales / Cl치sicos

### **1.1. Algoritmo de Euclides (M치ximo Com칰n Divisor - GCD)**

**Objetivo / Aplicaci칩n:** Calcular el m치ximo com칰n divisor de dos n칰meros enteros.

**Fundamento te칩rico:**
Basado en el principio de que el MCD entre dos n칰meros `a` y `b` (con `a > b`) es igual al MCD de `b` y el residuo de `a 칭 b`.
**Complejidad:** Temporal O(log min(a,b)) | Espacial O(1)
**Clasificaci칩n:** Matem치tico / Determin칤stico / Iterativo
**Origen:** Euclides (~300 a.C.)

```mermaid
flowchart TD
A[Inicio] --> B[Recibir a, b]
B --> C{b == 0?}
C -->|S칤| D[Retornar a]
C -->|No| E[a,b = b,a%b]
E --> C
```

```python
def mcd(a, b):
    while b != 0:
        a, b = b, a % b
    return a

print(mcd(48, 18))  # Resultado: 6
```

---

### **1.2. Criba de Erat칩stenes**

**Objetivo:** Generar todos los n칰meros primos hasta un valor `n`.
**Fundamento:** Marca m칰ltiplos de cada n칰mero primo como no primos.
**Complejidad:** Temporal O(n log log n) | Espacial O(n)
**Clasificaci칩n:** Matem치tico / Iterativo / Determin칤stico
**Origen:** Erat칩stenes de Cirene (~200 a.C.)

```mermaid
flowchart TD
A[Inicio] --> B[Crear lista de 2 a n]
B --> C[i = 2]
C --> D{ i*i <= n? }
D -->|S칤| E[Eliminar m칰ltiplos de i]
E --> F[i += 1]
F --> D
D -->|No| G[Retornar primos]
```

```python
def criba(n):
    primos = [True] * (n+1)
    primos[0:2] = [False, False]
    for i in range(2, int(n**0.5) + 1):
        if primos[i]:
            for j in range(i*i, n+1, i):
                primos[j] = False
    return [x for x in range(2, n+1) if primos[x]]

print(criba(30))
```

---

### **1.3. Exponentiaci칩n r치pida (Exponentiation by Squaring)**

**Objetivo:** Calcular `a^b` de forma eficiente.
**Fundamento:** Divide el exponente por 2 y usa propiedades de potencia.
**Complejidad:** Temporal O(log n) | Espacial O(1)
**Clasificaci칩n:** Matem치tico / Recursivo / Divide y vencer치s
**Origen:** Gauss (S. XIX)

```python
def potencia(a, n):
    if n == 0:
        return 1
    elif n % 2 == 0:
        mitad = potencia(a, n//2)
        return mitad * mitad
    else:
        return a * potencia(a, n-1)

print(potencia(3, 7))  # 2187
```

---

### **1.4. Transformada R치pida de Fourier (FFT)**

**Objetivo:** Calcular la transformada discreta de Fourier de manera eficiente.
**Fundamento:** Divide la se침al en pares/impares y aplica recursi칩n (divide y vencer치s).
**Complejidad:** O(n log n) | Espacial O(n)
**Clasificaci칩n:** Num칠rico / Recursivo / Divide y vencer치s
**Origen:** Cooley y Tukey (1965)

```python
import cmath

def fft(x):
    N = len(x)
    if N <= 1:
        return x
    pares = fft(x[0::2])
    impares = fft(x[1::2])
    factor = [cmath.exp(-2j * cmath.pi * k / N) * impares[k] for k in range(N//2)]
    return [pares[k] + factor[k] for k in range(N//2)] +            [pares[k] - factor[k] for k in range(N//2)]

print(fft([0,1,2,3]))
```

---

### **1.5. Newton-Raphson**

**Objetivo:** Aproximar ra칤ces de funciones f(x)=0.
**Fundamento:** Usa derivadas para aproximar mediante tangentes sucesivas.
**Complejidad:** O(k) donde k es n칰mero de iteraciones | Espacial O(1)
**Clasificaci칩n:** Num칠rico / Iterativo / Aproximado
**Origen:** Isaac Newton (1669), Joseph Raphson (1690)

```python
def newton(f, df, x0, tol=1e-6, max_iter=50):
    x = x0
    for _ in range(max_iter):
        x1 = x - f(x)/df(x)
        if abs(x1 - x) < tol:
            return x1
        x = x1
    return x

print(newton(lambda x: x**2 - 2, lambda x: 2*x, 1))
```

## 游닄 Referencias
- Cormen, T. H. *Introduction to Algorithms* (MIT Press, 2009)
- Goodrich & Tamassia. *Data Structures and Algorithms in Python* (Wiley, 2015)
- Downey, A. *Think Python*
- Sutton & Barto. *Reinforcement Learning: An Introduction*
- Mitchell, T. *Machine Learning* (McGraw-Hill)
