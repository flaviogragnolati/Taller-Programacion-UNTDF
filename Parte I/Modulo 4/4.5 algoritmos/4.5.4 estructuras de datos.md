# üß© M√≥dulo 4: Estructuras de Datos y Algoritmos B√°sicos
## **Secci√≥n 4: Estructuras de Datos y Gesti√≥n de Memoria**

---

### üß† Introducci√≥n General

Las **estructuras de datos** permiten almacenar, organizar y acceder eficientemente a la informaci√≥n.
Cada tipo de estructura est√° dise√±ada para resolver un tipo de problema espec√≠fico, optimizando el uso de **tiempo y memoria**.
En esta secci√≥n veremos estructuras cl√°sicas y avanzadas, con sus fundamentos y ejemplos en Python.

---

## üîπ 4.1. Hashing y Tablas Hash

**Objetivo / Aplicaci√≥n:**
Permitir **b√∫squeda, inserci√≥n y eliminaci√≥n en tiempo promedio O(1)**, utilizando una funci√≥n hash que mapea claves a posiciones en un array.

**Fundamento te√≥rico:**
Un valor clave se transforma en un √≠ndice mediante una **funci√≥n hash**. Las colisiones (claves distintas con mismo hash) se resuelven con **encadenamiento** o **direccionamiento abierto**.
**Complejidad temporal:** Promedio O(1), peor caso O(n) ¬∑ **Espacial:** O(n)
**Clasificaci√≥n:** Estructura asociativa ¬∑ Aleatoria ¬∑ Determin√≠stica
**Origen:** Formalizada por **Hans Peter Luhn (1953)**, IBM.

```mermaid
flowchart TD
A[Clave] --> B[Funci√≥n Hash]
B --> C[√çndice del array]
C --> D{Colisi√≥n?}
D -->|No| E[Insertar elemento]
D -->|S√≠| F[Resolver colisi√≥n (lista o nueva posici√≥n)]
```

```python
class HashTable:
    def __init__(self, size=10):
        self.size = size
        self.table = [[] for _ in range(size)]

    def _hash(self, key):
        return hash(key) % self.size

    def insert(self, key, value):
        idx = self._hash(key)
        for pair in self.table[idx]:
            if pair[0] == key:
                pair = (key, value)
                return
        self.table[idx].append((key, value))

    def get(self, key):
        idx = self._hash(key)
        for k, v in self.table[idx]:
            if k == key:
                return v
        return None

h = HashTable()
h.insert("nombre", "Flavio")
print(h.get("nombre"))
```

---

## üå≤ 4.2. √Årboles Balanceados (AVL / Red-Black)

**Objetivo / Aplicaci√≥n:**
Mantener los datos **ordenados** con **b√∫squeda, inserci√≥n y eliminaci√≥n en O(log n)**.
Evita el desbalanceo mediante rotaciones autom√°ticas.

**Fundamento te√≥rico:**
En un **√°rbol AVL**, la diferencia de alturas entre sub√°rboles izquierdo y derecho es ‚â§ 1.
**Complejidad temporal:** O(log n) para operaciones b√°sicas ¬∑ **Espacial:** O(n)
**Clasificaci√≥n:** √Årbol binario de b√∫squeda balanceado ¬∑ Determin√≠stico
**Origen:** **Adelson-Velsky y Landis (1962)**.

```mermaid
flowchart TD
A[Insertar nodo] --> B[Actualizar alturas]
B --> C{Desbalance?}
C -->|No| D[Fin]
C -->|S√≠| E[Rotaci√≥n simple o doble]
E --> D
```

```python
class Node:
    def __init__(self, key):
        self.key = key
        self.left = None
        self.right = None
        self.height = 1

def height(n): return n.height if n else 0

def rotate_right(y):
    x = y.left
    T2 = x.right
    x.right = y
    y.left = T2
    y.height = max(height(y.left), height(y.right)) + 1
    x.height = max(height(x.left), height(x.right)) + 1
    return x

def rotate_left(x):
    y = x.right
    T2 = y.left
    y.left = x
    x.right = T2
    x.height = max(height(x.left), height(x.right)) + 1
    y.height = max(height(y.left), height(y.right)) + 1
    return y

def balance_factor(n): return height(n.left) - height(n.right) if n else 0

def insert(root, key):
    if not root:
        return Node(key)
    if key < root.key:
        root.left = insert(root.left, key)
    else:
        root.right = insert(root.right, key)

    root.height = 1 + max(height(root.left), height(root.right))
    balance = balance_factor(root)
    if balance > 1 and key < root.left.key:
        return rotate_right(root)
    if balance < -1 and key > root.right.key:
        return rotate_left(root)
    if balance > 1 and key > root.left.key:
        root.left = rotate_left(root.left)
        return rotate_right(root)
    if balance < -1 and key < root.right.key:
        root.right = rotate_right(root.right)
        return rotate_left(root)
    return root

r = None
for k in [10,20,30,40,50,25]:
    r = insert(r,k)
print("Ra√≠z del √°rbol AVL:", r.key)
```

---

## ‚õ∞Ô∏è 4.3. Heap (Mont√≠culo Binario)

**Objetivo / Aplicaci√≥n:**
Estructura especializada para **extraer el elemento m√≠nimo o m√°ximo en O(log n)**.
Usada en colas de prioridad y algoritmos como **Dijkstra** o **HeapSort**.

**Fundamento te√≥rico:**
Un **heap binario** cumple la propiedad: cada nodo es ‚â§ (min-heap) o ‚â• (max-heap) que sus hijos.
**Complejidad temporal:** Inserci√≥n y extracci√≥n O(log n) ¬∑ **Espacial:** O(n)
**Clasificaci√≥n:** √Årbol binario completo ¬∑ Determin√≠stico
**Origen:** **J. W. J. Williams (1964)**.

```mermaid
flowchart TD
A[Insertar elemento] --> B[Colocar al final del array]
B --> C[Comparar con padre]
C --> D{Violaci√≥n de propiedad heap?}
D -->|S√≠| E[Intercambiar]
D -->|No| F[Fin]
E --> C
```

```python
import heapq

data = [5, 3, 8, 1, 2]
heapq.heapify(data)
heapq.heappush(data, 0)
print("Heap:", data)
print("Extraer menor:", heapq.heappop(data))
```

---

## üî§ 4.4. Trie (√Årbol de Prefijos)

**Objetivo / Aplicaci√≥n:**
Permitir b√∫squeda y almacenamiento eficiente de **cadenas o prefijos** (como autocompletado o diccionarios).

**Fundamento te√≥rico:**
Cada nodo representa un car√°cter, y las rutas definen palabras completas.
**Complejidad temporal:** O(L) por palabra (L = longitud) ¬∑ **Espacial:** O(N¬∑Œ£)
**Clasificaci√≥n:** √Årbol n-ario ¬∑ Determin√≠stico
**Origen:** **Ren√© de la Briandais (1959)**; nombre ‚ÄúTrie‚Äù de **Edward Fredkin (1960)**.

```mermaid
flowchart TD
A[Inicio] --> B[Recorrer caracteres]
B --> C{Existe hijo?}
C -->|S√≠| D[Seguir nodo]
C -->|No| E[Crear nuevo nodo]
E --> D
D --> F[Marcar fin de palabra]
```

```python
class TrieNode:
    def __init__(self):
        self.children = {}
        self.is_end = False

class Trie:
    def __init__(self):
        self.root = TrieNode()

    def insert(self, word):
        node = self.root
        for ch in word:
            if ch not in node.children:
                node.children[ch] = TrieNode()
            node = node.children[ch]
        node.is_end = True

    def search(self, word):
        node = self.root
        for ch in word:
            if ch not in node.children:
                return False
            node = node.children[ch]
        return node.is_end

trie = Trie()
trie.insert("flavio")
trie.insert("flor")
print(trie.search("flor"))  # True
print(trie.search("flores"))  # False
```

---

## üßÆ 4.5. Bloom Filter

**Objetivo / Aplicaci√≥n:**
Estructura **probabil√≠stica** para verificar si un elemento *puede* estar presente en un conjunto, con **falsos positivos posibles pero falsos negativos imposibles**.

**Fundamento te√≥rico:**
Usa m√∫ltiples **funciones hash** para marcar posiciones en un bit array.
**Complejidad temporal:** O(k) por operaci√≥n ¬∑ **Espacial:** O(m)
**Clasificaci√≥n:** Probabil√≠stico / No determin√≠stico / Estructura compacta
**Origen:** **Burton Howard Bloom (1970)**.

```mermaid
flowchart TD
A[Elemento] --> B[Aplicar k funciones hash]
B --> C[Actualizar bits en posiciones hash]
C --> D[Consultar bits -> posible presencia]
```

```python
import hashlib

class BloomFilter:
    def __init__(self, size=100):
        self.size = size
        self.bit_array = [0]*size

    def _hashes(self, item):
        return [int(hashlib.md5(item.encode()).hexdigest(), 16) % self.size,
                int(hashlib.sha1(item.encode()).hexdigest(), 16) % self.size]

    def add(self, item):
        for h in self._hashes(item):
            self.bit_array[h] = 1

    def check(self, item):
        return all(self.bit_array[h] for h in self._hashes(item))

bf = BloomFilter()
bf.add("python")
print(bf.check("python"))  # True
print(bf.check("java"))    # False (o True con baja probabilidad)
```

---

### ‚úÖ Cierre de la Secci√≥n 4

Estas estructuras son la base de la manipulaci√≥n eficiente de datos:
- **HashTable:** Acceso directo mediante claves.
- **√Årbol AVL:** Balance din√°mico de datos ordenados.
- **Heap:** Base de colas de prioridad.
- **Trie:** Almacenamiento de cadenas jer√°rquicas.
- **Bloom Filter:** Compresi√≥n probabil√≠stica sin almacenamiento exacto.

---
