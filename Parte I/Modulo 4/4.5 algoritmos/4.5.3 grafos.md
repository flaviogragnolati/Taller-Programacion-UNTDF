# ðŸ§© MÃ³dulo 4: Estructuras de Datos y Algoritmos BÃ¡sicos
## **SecciÃ³n 3: Algoritmos de Grafos**

---

### ðŸ§  IntroducciÃ³n General

Un **grafo** es una estructura matemÃ¡tica compuesta por **nodos (vÃ©rtices)** y **enlaces (aristas)** que los conectan.
Se utilizan para modelar redes, caminos, relaciones y dependencias en una amplia variedad de contextos: desde redes de transporte y comunicaciÃ³n hasta estructuras de datos y optimizaciÃ³n.

Los grafos pueden ser:
- **Dirigidos / No dirigidos**
- **Ponderados / No ponderados**
- **CÃ­clicos / AcÃ­clicos**

En programaciÃ³n, la representaciÃ³n mÃ¡s comÃºn y clara es la **lista de adyacencia**, implementada usualmente como un **diccionario** en Python.

---

## ðŸ”¹ 3.1. BÃºsqueda en Amplitud (Breadth-First Search â€“ BFS)

**Objetivo / AplicaciÃ³n:**
Recorrer un grafo nivel por nivel, encontrando el **camino mÃ¡s corto (en nÃºmero de aristas)** desde un nodo origen en grafos no ponderados.

**Fundamento teÃ³rico:**
Utiliza una **cola (queue)** para expandir los vÃ©rtices en orden creciente de distancia desde la raÃ­z.
**Complejidad temporal:** O(V + E) Â· **Espacial:** O(V)
**ClasificaciÃ³n:** Recorrido / DeterminÃ­stico / Iterativo / No ponderado
**Origen:** Formalizado por **E. F. Moore (1959)**.

```mermaid
flowchart TD
A[Inicio] --> B[Encolar nodo origen]
B --> C{Cola vacÃ­a?}
C -->|SÃ­| D[Fin]
C -->|No| E[Desencolar nodo]
E --> F[Visitar vecinos no visitados]
F --> G[Encolar vecinos]
G --> C
```

```python
from collections import deque

def bfs(graph, start):
    visitado = set([start])
    cola = deque([start])
    while cola:
        nodo = cola.popleft()
        print(nodo, end=" ")
        for vecino in graph[nodo]:
            if vecino not in visitado:
                visitado.add(vecino)
                cola.append(vecino)

grafo = {
    'A': ['B', 'C'],
    'B': ['D', 'E'],
    'C': ['F'],
    'D': [], 'E': ['F'], 'F': []
}
bfs(grafo, 'A')
```

---

## ðŸ”¹ 3.2. BÃºsqueda en Profundidad (Depth-First Search â€“ DFS)

**Objetivo / AplicaciÃ³n:**
Recorrer el grafo explorando cada camino hasta su fin antes de retroceder; Ãºtil para **detecciÃ³n de ciclos**, **topological sort**, y **componentes conexas**.

**Fundamento teÃ³rico:**
Usa una **pila (stack)** o recursiÃ³n para explorar recursivamente los nodos.
**Complejidad temporal:** O(V + E) Â· **Espacial:** O(V) (por recursiÃ³n)
**ClasificaciÃ³n:** Recorrido / DeterminÃ­stico / Recursivo
**Origen:** Descrito formalmente por **TrÃ©maux (1859)** y usado en teorÃ­a de grafos moderna.

```mermaid
flowchart TD
A[Inicio] --> B[Visitar nodo actual]
B --> C[Marcar como visitado]
C --> D[Explorar vecino no visitado]
D --> E[Llamada recursiva]
E --> D
D --> F[Retornar]
```

```python
def dfs(graph, nodo, visitado=None):
    if visitado is None:
        visitado = set()
    visitado.add(nodo)
    print(nodo, end=" ")
    for vecino in graph[nodo]:
        if vecino not in visitado:
            dfs(graph, vecino, visitado)

grafo = {
    'A': ['B', 'C'],
    'B': ['D', 'E'],
    'C': ['F'],
    'D': [], 'E': ['F'], 'F': []
}
dfs(grafo, 'A')
```

---

## ðŸ”¹ 3.3. Algoritmo de Dijkstra

**Objetivo / AplicaciÃ³n:**
Encontrar la **ruta mÃ¡s corta** desde un nodo origen hacia todos los demÃ¡s en un grafo **ponderado con pesos no negativos**.

**Fundamento teÃ³rico:**
Mantiene una **cola de prioridad** para expandir el nodo con menor distancia acumulada.
**Complejidad temporal:** O((V + E) log V) usando heap Â· **Espacial:** O(V)
**ClasificaciÃ³n:** Caminos mÃ­nimos / Greedy / DeterminÃ­stico
**Origen:** **Edsger Dijkstra (1956)**

```mermaid
flowchart TD
A[Inicio] --> B[Inicializar distancias = âˆž]
B --> C[dist[start]=0]
C --> D[Usar cola de prioridad]
D --> E[Extraer nodo con menor distancia]
E --> F[Actualizar distancias de vecinos]
F --> G{Cola vacÃ­a?}
G -->|No| E
G -->|SÃ­| H[Fin]
```

```python
import heapq

def dijkstra(graph, start):
    dist = {v: float('inf') for v in graph}
    dist[start] = 0
    pq = [(0, start)]
    while pq:
        d, u = heapq.heappop(pq)
        if d > dist[u]:
            continue
        for v, w in graph[u]:
            if dist[u] + w < dist[v]:
                dist[v] = dist[u] + w
                heapq.heappush(pq, (dist[v], v))
    return dist

grafo = {
    'A': [('B', 2), ('C', 5)],
    'B': [('C', 1), ('D', 3)],
    'C': [('D', 2)],
    'D': []
}
print(dijkstra(grafo, 'A'))
```

---

## ðŸ”¹ 3.4. Bellman-Ford

**Objetivo / AplicaciÃ³n:**
Encontrar caminos mÃ¡s cortos incluso con **pesos negativos**, detectando si existen **ciclos negativos**.

**Fundamento teÃ³rico:**
Relaja todas las aristas Vâˆ’1 veces y verifica ciclos en una iteraciÃ³n adicional.
**Complejidad temporal:** O(VÂ·E) Â· **Espacial:** O(V)
**ClasificaciÃ³n:** Caminos mÃ­nimos / DeterminÃ­stico / DinÃ¡mico
**Origen:** **Richard Bellman (1958)** y **Lester Ford (1956)**

```python
def bellman_ford(edges, V, start):
    dist = {v: float('inf') for v in range(V)}
    dist[start] = 0
    for _ in range(V-1):
        for u, v, w in edges:
            if dist[u] + w < dist[v]:
                dist[v] = dist[u] + w
    # detecciÃ³n de ciclo negativo
    for u, v, w in edges:
        if dist[u] + w < dist[v]:
            raise ValueError("Ciclo negativo detectado")
    return dist

edges = [(0,1,5),(0,2,4),(1,3,3),(2,1,6),(3,2,-2)]
print(bellman_ford(edges, 4, 0))
```

---

## ðŸ”¹ 3.5. Floyd-Warshall

**Objetivo / AplicaciÃ³n:**
Encontrar los **caminos mÃ¡s cortos entre todos los pares de vÃ©rtices**.
**Fundamento teÃ³rico:**
Relaja todas las combinaciones posibles mediante programaciÃ³n dinÃ¡mica.
**Complejidad temporal:** O(VÂ³) Â· **Espacial:** O(VÂ²)
**ClasificaciÃ³n:** Caminos mÃ­nimos / DinÃ¡mico / DeterminÃ­stico
**Origen:** **Robert Floyd (1962)** y **Stephen Warshall (1962)**

```python
def floyd_warshall(dist):
    n = len(dist)
    for k in range(n):
        for i in range(n):
            for j in range(n):
                if dist[i][k] + dist[k][j] < dist[i][j]:
                    dist[i][j] = dist[i][k] + dist[k][j]
    return dist

mat = [
    [0, 5, float('inf'), 10],
    [float('inf'), 0, 3, float('inf')],
    [float('inf'), float('inf'), 0, 1],
    [float('inf'), float('inf'), float('inf'), 0]
]
for fila in floyd_warshall(mat):
    print(fila)
```

---

## ðŸ”¹ 3.6. Prim (Ãrbol de ExpansiÃ³n MÃ­nima)

**Objetivo / AplicaciÃ³n:**
Encontrar el **Ã¡rbol de expansiÃ³n mÃ­nima (MST)** conectando todos los vÃ©rtices con el **menor peso total**.

**Fundamento teÃ³rico:**
Expande un Ã¡rbol conectando el vÃ©rtice mÃ¡s cercano aÃºn no incluido.
**Complejidad temporal:** O(E log V) con heap Â· **Espacial:** O(V)
**ClasificaciÃ³n:** Greedy / DeterminÃ­stico / Ãrbol mÃ­nimo
**Origen:** **Robert Prim (1957)**

```python
import heapq

def prim(graph, start):
    visit = set([start])
    edges = [(w, start, v) for v, w in graph[start]]
    heapq.heapify(edges)
    mst = []
    while edges:
        w, u, v = heapq.heappop(edges)
        if v not in visit:
            visit.add(v)
            mst.append((u, v, w))
            for nxt, w2 in graph[v]:
                if nxt not in visit:
                    heapq.heappush(edges, (w2, v, nxt))
    return mst

grafo = {
    'A': [('B', 1), ('C', 3)],
    'B': [('A', 1), ('C', 1), ('D', 4)],
    'C': [('A', 3), ('B', 1), ('D', 1)],
    'D': [('B', 4), ('C', 1)]
}
print(prim(grafo, 'A'))
```

---

## ðŸ”¹ 3.7. Kruskal

**Objetivo / AplicaciÃ³n:**
Construir el MST seleccionando aristas en orden creciente de peso sin formar ciclos.
**Fundamento teÃ³rico:**
Usa estructura **Union-Find** para detectar ciclos.
**Complejidad temporal:** O(E log E) Â· **Espacial:** O(V)
**ClasificaciÃ³n:** Greedy / DeterminÃ­stico / Ãrbol mÃ­nimo
**Origen:** **Joseph Kruskal (1956)**

```python
def kruskal(edges, V):
    parent = list(range(V))
    def find(x):
        while parent[x] != x:
            x = parent[x]
        return x
    def union(x, y):
        px, py = find(x), find(y)
        if px != py:
            parent[py] = px

    edges.sort(key=lambda x: x[2])
    mst = []
    for u, v, w in edges:
        if find(u) != find(v):
            union(u, v)
            mst.append((u, v, w))
    return mst

edges = [(0,1,1),(1,2,1),(0,2,3),(1,3,4),(2,3,1)]
print(kruskal(edges, 4))
```

---

## ðŸ”¹ 3.8. A* (A-Star)

**Objetivo / AplicaciÃ³n:**
Buscar el **camino mÃ¡s corto** utilizando una **heurÃ­stica informada** (estimaciÃ³n al destino).
**Fundamento teÃ³rico:**
Combina costo real (g) y heurÃ­stico (h): `f(n) = g(n) + h(n)`
**Complejidad:** Depende de la heurÃ­stica Â· **ClasificaciÃ³n:** HeurÃ­stico / IA / Informado
**Origen:** **Hart, Nilsson y Raphael (1968)**

```python
import heapq

def astar(graph, start, goal, h):
    pq = [(0 + h[start], 0, start, [])]
    visited = set()
    while pq:
        f, g, node, path = heapq.heappop(pq)
        if node == goal:
            return path + [node]
        if node in visited:
            continue
        visited.add(node)
        for neigh, w in graph[node]:
            heapq.heappush(pq, (g+w+h[neigh], g+w, neigh, path+[node]))
    return None

grafo = {'A':[('B',1),('C',3)],'B':[('D',1)],'C':[('D',1)],'D':[]}
heur = {'A':2,'B':1,'C':1,'D':0}
print(astar(grafo,'A','D',heur))
```

---

## ðŸ”¹ 3.9. Topological Sort

**Objetivo / AplicaciÃ³n:**
Ordenar nodos de un **grafo dirigido acÃ­clico (DAG)** en secuencia tal que toda arista (uâ†’v) respete el orden.
**Complejidad temporal:** O(V + E) Â· **Espacial:** O(V)
**ClasificaciÃ³n:** Ordenamiento / DeterminÃ­stico / DAG
**Origen:** Concepto formalizado en teorÃ­a de grafos moderna.

```python
def topological_sort(graph):
    visited, stack = set(), []
    def dfs(v):
        visited.add(v)
        for n in graph[v]:
            if n not in visited:
                dfs(n)
        stack.append(v)
    for v in graph:
        if v not in visited:
            dfs(v)
    return stack[::-1]

grafo = {'A':['B','C'],'B':['D'],'C':['D'],'D':[]}
print(topological_sort(grafo))
```

---

## ðŸ”¹ 3.10. Tarjan â€“ Componentes Fuertemente Conexas

**Objetivo / AplicaciÃ³n:**
Identificar **subgrafos fuertemente conexos (SCCs)** en un grafo dirigido.
**Fundamento teÃ³rico:**
Usa DFS con Ã­ndices y pila para agrupar vÃ©rtices interconectados.
**Complejidad:** O(V + E) Â· **ClasificaciÃ³n:** AnÃ¡lisis estructural / DFS / DeterminÃ­stico
**Origen:** **Robert Tarjan (1972)**

```python
def tarjanscc(graph):
    index, stack, lowlink, onstack = {}, [], {}, set()
    result = []
    i = 0

    def dfs(v):
        nonlocal i
        index[v] = lowlink[v] = i; i += 1
        stack.append(v); onstack.add(v)
        for w in graph[v]:
            if w not in index:
                dfs(w); lowlink[v] = min(lowlink[v], lowlink[w])
            elif w in onstack:
                lowlink[v] = min(lowlink[v], index[w])
        if lowlink[v] == index[v]:
            comp = []
            while True:
                w = stack.pop(); onstack.remove(w); comp.append(w)
                if w == v: break
            result.append(comp)

    for v in graph:
        if v not in index:
            dfs(v)
    return result

grafo = {'A':['B'],'B':['C'],'C':['A','D'],'D':['E'],'E':['D']}
print(tarjanscc(grafo))
```

---

### âœ… Cierre de la SecciÃ³n 3

Los **algoritmos de grafos** son esenciales para la representaciÃ³n de redes y la resoluciÃ³n de problemas de optimizaciÃ³n, navegaciÃ³n, planificaciÃ³n y anÃ¡lisis estructural.
- **BFS/DFS**: recorridos fundamentales.
- **Dijkstra / Bellman-Ford / Floyd-Warshall**: caminos mÃ¡s cortos.
- **Prim / Kruskal**: Ã¡rboles mÃ­nimos.
- **A***: bÃºsqueda informada con heurÃ­sticas.
- **Topological / Tarjan**: estructura y orden de grafos dirigidos.

---
