# üß© M√≥dulo 4: Estructuras de Datos y Algoritmos B√°sicos
## **Secci√≥n 8: Algoritmos Distribuidos y de Redes**

---

### üß† Introducci√≥n General

Los **algoritmos distribuidos** permiten que m√∫ltiples procesos, ejecut√°ndose en distintos nodos de una red, trabajen coordinadamente para resolver un problema com√∫n.
Se aplican en **sistemas de consenso, replicaci√≥n de datos, procesamiento paralelo y redes P2P**.

Los principales desaf√≠os son la **sincronizaci√≥n, tolerancia a fallos, consistencia y latencia**.

---

## üîπ 8.1. Raft ‚Äì Consenso Distribuido

**Objetivo / Aplicaci√≥n:**
Lograr que m√∫ltiples servidores (nodos) acuerden un mismo estado del sistema (por ejemplo, una bit√°cora compartida).
Raft es m√°s f√°cil de entender y de implementar que Paxos, aunque logran objetivos equivalentes.

**Fundamento te√≥rico:**
Divide el proceso en tres fases:
1. **Elecci√≥n de l√≠der**
2. **Replicaci√≥n de log**
3. **Compromiso de entradas**

**Complejidad:** Comunicaci√≥n O(n) por ciclo ¬∑ **Clasificaci√≥n:** Consenso / Tolerante a fallos / Determin√≠stico
**Origen:** **Diego Ongaro y John Ousterhout (2014)**.

```mermaid
flowchart TD
A[Inicio] --> B[Elecci√≥n de L√≠der]
B --> C[L√≠der elegido]
C --> D[Cliente env√≠a comando]
D --> E[L√≠der replica a seguidores]
E --> F[Seguidores confirman]
F --> G[L√≠der aplica comando]
G --> H[Replicaci√≥n consistente]
```

```python
# Simulaci√≥n conceptual de consenso Raft
import random

nodos = ["N1","N2","N3"]
lider = random.choice(nodos)
log = []

def replicar(comando):
    print(f"L√≠der {lider} propone '{comando}'")
    ack = [n for n in nodos if random.random() > 0.1]
    if len(ack) >= 2:
        log.append(comando)
        print("Consenso alcanzado:", log)
    else:
        print("Fallo en consenso")

replicar("actualizar estado")
```

---

## üîπ 8.2. Paxos ‚Äì Acuerdo en sistemas distribuidos

**Objetivo / Aplicaci√≥n:**
Asegurar consenso entre nodos incluso en presencia de fallos de red o procesos.
Usado en sistemas de bases distribuidas como **Google Chubby** o **ZooKeeper**.

**Fundamento te√≥rico:**
Opera con roles: **Proposers**, **Acceptors**, **Learners**, garantizando que s√≥lo una propuesta sea aceptada.
**Complejidad:** O(n¬≤) mensajes por ronda ¬∑ **Clasificaci√≥n:** Consenso / Tolerante a fallos / As√≠ncrono
**Origen:** **Leslie Lamport (1990)**.

```mermaid
flowchart TD
A[Proposer env√≠a propuesta] --> B[Acceptors responden promesa]
B --> C[Proposer env√≠a valor final]
C --> D[Acceptors aceptan]
D --> E[Learners aprenden valor]
E --> F[Consenso alcanzado]
```

```python
import random

def paxos_propuesta(valor):
    acceptors = 5
    votos = 0
    for i in range(acceptors):
        if random.random() > 0.3:
            votos += 1
    if votos > acceptors/2:
        print("Valor aceptado:", valor)
    else:
        print("Fallo de consenso")

paxos_propuesta("x=42")
```

---

## üîπ 8.3. MapReduce ‚Äì Procesamiento Distribuido

**Objetivo / Aplicaci√≥n:**
Procesar grandes vol√∫menes de datos distribuidos en m√∫ltiples nodos de manera paralela.
Base de sistemas como **Hadoop** y **Spark**.

**Fundamento te√≥rico:**
Divide el problema en dos fases:
1. **Map:** transforma o clasifica los datos.
2. **Reduce:** combina resultados parciales.
**Complejidad:** O(n/p) por nodo (p = n√∫mero de nodos) ¬∑ **Clasificaci√≥n:** Paralelizable / Determin√≠stico
**Origen:** **Dean y Ghemawat, Google (2004)**.

```mermaid
flowchart TD
A[Datos de entrada] --> B[Fase Map]
B --> C[Mapeo paralelo en nodos]
C --> D[Fase Shuffle (agrupamiento)]
D --> E[Fase Reduce]
E --> F[Resultado combinado]
```

```python
from collections import defaultdict

data = ["uno", "dos", "uno", "tres", "dos", "uno"]

def map_step(palabra): return (palabra, 1)

def reduce_step(mapped):
    resultado = defaultdict(int)
    for k,v in mapped:
        resultado[k]+=v
    return resultado

mapped = [map_step(w) for w in data]
reduced = reduce_step(mapped)
print(dict(reduced))
```

---

## üîπ 8.4. PageRank ‚Äì Relevancia en Grafos Web

**Objetivo / Aplicaci√≥n:**
Determinar la **importancia de las p√°ginas web** en funci√≥n de los enlaces que reciben.
Es la base del algoritmo de clasificaci√≥n original de **Google Search**.

**Fundamento te√≥rico:**
Modelo de un **pase aleatorio** en un grafo: la probabilidad de estar en una p√°gina depende de los enlaces entrantes.
**Complejidad:** O(k¬∑(V+E)) ¬∑ **Clasificaci√≥n:** Algoritmo de grafos / Iterativo / Estoc√°stico
**Origen:** **Larry Page y Sergey Brin (1998)**.

```mermaid
flowchart TD
A[Inicializar rank en 1/N] --> B[Distribuir rank entre enlaces salientes]
B --> C[Sumar contribuciones entrantes]
C --> D[Aplicar factor de amortiguamiento d]
D --> E[Normalizar y repetir hasta converger]
```

```python
def pagerank(grafo, d=0.85, it=10):
    N = len(grafo)
    rank = {n:1/N for n in grafo}
    for _ in range(it):
        nuevo = {n:(1-d)/N for n in grafo}
        for n, enlaces in grafo.items():
            for e in enlaces:
                nuevo[e] += d * rank[n] / len(enlaces)
        rank = nuevo
    return rank

web = {'A':['B','C'], 'B':['C'], 'C':['A'], 'D':['C']}
print(pagerank(web))
```

---

## üîπ 8.5. Flooding y Gossip Protocols

**Objetivo / Aplicaci√≥n:**
Difundir informaci√≥n en una red de nodos, como en sistemas P2P o detecci√≥n de fallos.
El flooding propaga mensajes a **todos los vecinos**; los gossip lo hace **aleatoriamente**.

**Fundamento te√≥rico:**
Flooding garantiza cobertura total (con redundancia alta). Gossip reduce tr√°fico, pero con probabilidad de omisi√≥n.
**Complejidad:** Flooding O(E), Gossip O(log n) promedio ¬∑ **Clasificaci√≥n:** Difusi√≥n / Probabil√≠stico / Distribuido
**Origen:** Modelos de redes descentralizadas (d√©cadas de 1980‚Äì2000).

```mermaid
flowchart TD
A[Nodo emite mensaje] --> B[Envia a vecinos]
B --> C[Vecinos reenv√≠an a sus vecinos]
C --> D{Ya recibido?}
D -->|S√≠| E[Ignorar mensaje]
D -->|No| F[Reenviar a otros]
```

```python
import random

red = {'A':['B','C'], 'B':['A','D'], 'C':['A','D'], 'D':['B','C']}
recibido = set()

def gossip(origen, mensaje, p=0.6):
    if origen in recibido: return
    recibido.add(origen)
    print(f"{origen} recibi√≥: {mensaje}")
    for vecino in red[origen]:
        if random.random() < p:
            gossip(vecino, mensaje)

gossip('A', "actualizaci√≥n del sistema")
```

---

### ‚úÖ Cierre de la Secci√≥n 8

Los algoritmos distribuidos son la base del funcionamiento de **internet moderna, sistemas de archivos distribuidos, blockchain, cloud computing y redes sociales**.
- **Raft / Paxos:** consenso y coherencia.
- **MapReduce:** procesamiento masivo.
- **PageRank:** an√°lisis de conectividad.
- **Flooding / Gossip:** difusi√≥n resiliente de informaci√≥n.

---
