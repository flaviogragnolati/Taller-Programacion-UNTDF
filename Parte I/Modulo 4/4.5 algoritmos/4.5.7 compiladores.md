# üß© M√≥dulo 4: Estructuras de Datos y Algoritmos B√°sicos
## **Secci√≥n 7: Compiladores y Procesamiento de Lenguajes**

---

### üß† Introducci√≥n General

Los **compiladores** son programas que traducen c√≥digo fuente (de alto nivel) a un formato ejecutable (bajo nivel o m√°quina).
El proceso involucra **an√°lisis l√©xico, sint√°ctico, sem√°ntico, optimizaci√≥n y generaci√≥n de c√≥digo**.

En esta secci√≥n veremos algoritmos esenciales para el procesamiento de lenguajes formales y compresi√≥n.

---

## üîπ 7.1. Algoritmo Shunting Yard (Dijkstra)

**Objetivo / Aplicaci√≥n:**
Convertir expresiones **infijas** (ej. `3 + 4 * 2`) en **postfijas (RPN)**, facilitando la evaluaci√≥n mediante una pila.

**Fundamento te√≥rico:**
Usa dos pilas: una para **operandos** y otra para **operadores**, aplicando precedencia y asociatividad.
**Complejidad temporal:** O(n) ¬∑ **Espacial:** O(n)
**Clasificaci√≥n:** An√°lisis sint√°ctico / Determin√≠stico / Basado en pila
**Origen:** **Edsger Dijkstra (1961)**.

```mermaid
flowchart TD
A[Inicio] --> B[Leer token]
B --> C{Operando?}
C -->|S√≠| D[Agregar a salida]
C -->|No| E{Operador?}
E -->|S√≠| F[Comparar precedencia]
F --> G[Desapilar operadores mayores o iguales]
G --> H[Apilar operador]
E -->|No (par√©ntesis)| I[Gestionar par√©ntesis]
I --> J[Siguiente token]
J --> B
B -->|Fin entrada| K[Vaciar pila a salida]
K --> L[Expresi√≥n postfija]
```

```python
def shunting_yard(expr):
    prec = {'+':1, '-':1, '*':2, '/':2}
    output, stack = [], []
    for token in expr.split():
        if token.isnumeric():
            output.append(token)
        elif token in prec:
            while stack and prec.get(stack[-1],0) >= prec[token]:
                output.append(stack.pop())
            stack.append(token)
        elif token == '(':
            stack.append(token)
        elif token == ')':
            while stack and stack[-1] != '(':
                output.append(stack.pop())
            stack.pop()
    while stack:
        output.append(stack.pop())
    return output

print("Postfija:", shunting_yard("3 + 4 * 2 / ( 1 - 5 )"))
```

---

## üîπ 7.2. Parsing LL(1)

**Objetivo / Aplicaci√≥n:**
Analizar una secuencia de tokens **de izquierda a derecha** aplicando **descenso recursivo**.
Usado en compiladores simples y gram√°ticas sin ambig√ºedad.

**Fundamento te√≥rico:**
Cada paso se gu√≠a por el **primer s√≠mbolo esperado** seg√∫n una tabla predictiva.
**Complejidad:** O(n) ¬∑ **Clasificaci√≥n:** Determin√≠stico / Predictivo
**Origen:** Teor√≠a formal de compiladores (1960s).

```mermaid
flowchart TD
A[Inicio] --> B[Leer token actual]
B --> C{Coincide con la producci√≥n esperada?}
C -->|S√≠| D[Avanzar al siguiente token]
C -->|No| E[Error de sintaxis]
D --> B
B -->|Fin| F[Cadena aceptada]
```

```python
# Ejemplo LL(1) simple: Gram√°tica E -> T + E | T ; T -> int
tokens = ["int", "+", "int"]
pos = 0

def E():
    global pos
    T()
    if pos < len(tokens) and tokens[pos] == "+":
        pos += 1
        E()

def T():
    global pos
    if pos < len(tokens) and tokens[pos] == "int":
        pos += 1
    else:
        raise ValueError("Error de sintaxis")

E()
print("Cadena aceptada" if pos == len(tokens) else "Error")
```

---

## üîπ 7.3. Parsing LR(0)

**Objetivo / Aplicaci√≥n:**
Analizar **de izquierda a derecha** construyendo derivaciones **a la derecha m√°s interna**.
Usado en compiladores reales (p. ej., yacc, bison).

**Fundamento te√≥rico:**
Basado en una **pila de s√≠mbolos** y una tabla de acciones (shift/reduce).
**Complejidad:** O(n) ¬∑ **Clasificaci√≥n:** Determin√≠stico / Basado en tabla
**Origen:** **Donald Knuth (1965)**.

```mermaid
flowchart TD
A[Inicio] --> B[Leer token]
B --> C{Acci√≥n?}
C -->|Shift| D[Apilar token]
C -->|Reduce| E[Aplicar producci√≥n]
E --> D
C -->|Accept| F[Fin - Sintaxis v√°lida]
C -->|Error| G[Rechazar]
D --> B
```

```python
# Ejemplo conceptual simplificado de parser LR(0)
input_tokens = list("id+id*id$")
stack = ["$"]
print("Simulaci√≥n LR(0):")
while True:
    top = stack[-1]
    tok = input_tokens[0]
    if tok == "$" and top == "$":
        print("‚úî Cadena aceptada")
        break
    elif tok.isalnum():
        stack.append("id")
        input_tokens.pop(0)
    elif tok in "+*":
        stack.append(tok)
        input_tokens.pop(0)
    else:
        print("Reducir producci√≥n")
        stack.pop()
```

---

## üîπ 7.4. Algoritmo de Huffman (Compresi√≥n)

**Objetivo / Aplicaci√≥n:**
Generar c√≥digos binarios √≥ptimos para cada s√≠mbolo seg√∫n su frecuencia, logrando **compresi√≥n sin p√©rdida**.

**Fundamento te√≥rico:**
Crea un **√°rbol binario de frecuencias** donde las hojas m√°s frecuentes tienen c√≥digos m√°s cortos.
**Complejidad:** O(n log n) ¬∑ **Clasificaci√≥n:** Codificaci√≥n √≥ptima / Greedy
**Origen:** **David Huffman (1952)**.

```mermaid
flowchart TD
A[Contar frecuencias] --> B[Construir √°rbol binario]
B --> C[Asignar 0 a la izquierda, 1 a la derecha]
C --> D[Generar c√≥digos por s√≠mbolo]
D --> E[Codificar mensaje]
```

```python
import heapq

def huffman_encode(data):
    freq = {}
    for c in data: freq[c] = freq.get(c,0)+1
    heap = [[f,[c,""]] for c,f in freq.items()]
    heapq.heapify(heap)
    while len(heap)>1:
        lo=heapq.heappop(heap); hi=heapq.heappop(heap)
        for pair in lo[1:]: pair[1]='0'+pair[1]
        for pair in hi[1:]: pair[1]='1'+pair[1]
        heapq.heappush(heap,[lo[0]+hi[0]]+lo[1:]+hi[1:])
    return sorted(heapq.heappop(heap)[1:], key=lambda p:(len(p[-1]),p))

msg = "hola mundo"
codes = huffman_encode(msg)
print("C√≥digos Huffman:", codes)
```

---

## üß© 7.5. Diagrama General del Proceso de Compilaci√≥n

```mermaid
flowchart TD
A[Programa Fuente] --> B[An√°lisis L√©xico]
B --> C[An√°lisis Sint√°ctico (Parsing)]
C --> D[An√°lisis Sem√°ntico]
D --> E[Optimizaci√≥n de C√≥digo]
E --> F[Generaci√≥n de C√≥digo Intermedio]
F --> G[Generaci√≥n de C√≥digo M√°quina]
G --> H[Programa Ejecutable]
```

### Explicaci√≥n:
1. **An√°lisis l√©xico:** convierte texto en tokens.
2. **An√°lisis sint√°ctico:** construye el √°rbol de derivaci√≥n (usando algoritmos como LL o LR).
3. **An√°lisis sem√°ntico:** valida tipos y contexto.
4. **Optimizaci√≥n:** mejora el rendimiento sin alterar el resultado.
5. **Generaci√≥n de c√≥digo:** traduce a lenguaje de m√°quina o intermedio (bytecode).

---

### ‚úÖ Cierre de la Secci√≥n 7

Los compiladores son uno de los pilares del desarrollo de software.
Los algoritmos vistos (Shunting Yard, Parsing LL/LR, Huffman) representan los fundamentos del procesamiento estructurado de lenguajes y la optimizaci√≥n de datos.

---
