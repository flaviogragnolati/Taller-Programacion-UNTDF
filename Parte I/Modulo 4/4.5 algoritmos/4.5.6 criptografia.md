# üß© M√≥dulo 4: Estructuras de Datos y Algoritmos B√°sicos
## **Secci√≥n 6: Criptograf√≠a y Seguridad**

---

### üß† Introducci√≥n General

La **criptograf√≠a** estudia los m√©todos para proteger la informaci√≥n mediante **transformaciones matem√°ticas** que impiden el acceso no autorizado.
Se basa en dos grandes paradigmas:

- **Cifrado sim√©trico:** misma clave para cifrar y descifrar.
- **Cifrado asim√©trico:** clave p√∫blica y clave privada.

A esto se suman las **funciones hash** (resumen irrepetible de datos) y los sistemas de **firma digital y autenticaci√≥n**.

---

## üîπ 6.1. RSA (Rivest‚ÄìShamir‚ÄìAdleman)

**Objetivo / Aplicaci√≥n:**
Proveer **cifrado asim√©trico** y **firmas digitales** mediante operaciones de exponenciaci√≥n modular con grandes primos.

**Fundamento te√≥rico:**
Se basa en la dificultad de factorizar n√∫meros grandes.
Genera dos claves: p√∫blica `(n, e)` y privada `(n, d)` tales que:
`c = m^e mod n` y `m = c^d mod n`.
**Complejidad:** Exponenciaci√≥n modular O(log¬≥ n) ¬∑ **Clasificaci√≥n:** Cifrado asim√©trico / Determin√≠stico
**Origen:** **Rivest, Shamir y Adleman (1977)**.

```mermaid
flowchart TD
A[Generar primos p,q] --> B[Calcular n=p*q y œÜ=(p-1)(q-1)]
B --> C[Elegir e coprimo con œÜ]
C --> D[Calcular d = e‚Åª¬π mod œÜ]
D --> E[Clave p√∫blica=(n,e), privada=(n,d)]
E --> F[Cifrar m‚Üíc = m^e mod n]
F --> G[Descifrar c‚Üím = c^d mod n]
```

```python
def gcd(a,b):
    while b:
        a,b=b,a%b
    return a

def modinv(a,m):
    for x in range(1,m):
        if (a*x)%m==1:
            return x
    return None

def rsa_keygen():
    p,q=61,53
    n=p*q
    phi=(p-1)*(q-1)
    e=17
    d=modinv(e,phi)
    return (e,d,n)

e,d,n=rsa_keygen()
m=65
c=pow(m,e,n)
m2=pow(c,d,n)
print("Mensaje cifrado:",c,"Descifrado:",m2)
```

---

## üîπ 6.2. Intercambio de Claves Diffie-Hellman

**Objetivo / Aplicaci√≥n:**
Permitir que dos partes acuerden una **clave secreta compartida** sin transmitirla expl√≠citamente.

**Fundamento te√≥rico:**
Basado en la dificultad del **problema del logaritmo discreto** en grupos finitos.
**Complejidad:** O(log n) para operaciones ¬∑ **Clasificaci√≥n:** Intercambio de claves / Asim√©trico / Determin√≠stico
**Origen:** **Whitfield Diffie y Martin Hellman (1976)**.

```mermaid
flowchart TD
A[Alice elige a] --> B[Bob elige b]
B --> C[Ambos conocen g,p]
C --> D[Alice envia A=g^a mod p]
C --> E[Bob envia B=g^b mod p]
D --> F[Alice calcula K=B^a mod p]
E --> G[Bob calcula K=A^b mod p]
F --> H[K es clave compartida]
G --> H
```

```python
p = 23  # n√∫mero primo
g = 5   # generador
a = 6   # secreto de Alice
b = 15  # secreto de Bob

A = pow(g, a, p)
B = pow(g, b, p)
Ka = pow(B, a, p)
Kb = pow(A, b, p)
print("Clave compartida:", Ka, Kb)
```

---

## üîπ 6.3. Funciones Hash (SHA / MD5)

**Objetivo / Aplicaci√≥n:**
Transformar datos arbitrarios en un **resumen fijo** (hash). Ideal para verificaci√≥n de integridad, almacenamiento y autenticaci√≥n.

**Fundamento te√≥rico:**
Una buena funci√≥n hash debe ser **unidireccional** (no reversible) y **resistente a colisiones**.
**Complejidad:** O(n) respecto al tama√±o del mensaje ¬∑ **Clasificaci√≥n:** Hash criptogr√°fico / Determin√≠stico
**Origen:** **Ron Rivest (MD5, 1991)** y **NSA (SHA, 1993)**.

```mermaid
flowchart TD
A[Mensaje] --> B[Dividir en bloques]
B --> C[Aplicar operaciones hash no reversibles]
C --> D[Combinar resultados parciales]
D --> E[Obtener hash final]
```

```python
import hashlib

texto = "seguridad"
print("MD5:", hashlib.md5(texto.encode()).hexdigest())
print("SHA1:", hashlib.sha1(texto.encode()).hexdigest())
print("SHA256:", hashlib.sha256(texto.encode()).hexdigest())
```

---

## üîπ 6.4. Cifrado Sim√©trico (AES / DES)

**Objetivo / Aplicaci√≥n:**
Cifrar datos utilizando **la misma clave para cifrar y descifrar**.
AES reemplaz√≥ a DES como est√°ndar internacional por su mayor seguridad y longitud de clave.

**Fundamento te√≥rico:**
Divide el mensaje en **bloques**, aplica **sustituci√≥n, permutaci√≥n y mezcla** controladas por la clave.
**Complejidad:** O(n) sobre longitud del texto ¬∑ **Clasificaci√≥n:** Cifrado por bloques / Determin√≠stico
**Origen:** **DES (IBM, 1977)** ¬∑ **AES (Daemen y Rijmen, 2001)**.

```mermaid
flowchart TD
A[Texto plano] --> B[Dividir en bloques]
B --> C[Aplicar sustituci√≥n S-Box]
C --> D[Permutaci√≥n y mezcla]
D --> E[XOR con subclave]
E --> F[Texto cifrado]
```

```python
# Ejemplo did√°ctico de XOR cifrado (concepto base del cifrado sim√©trico)
def xor_cipher(texto, clave):
    return ''.join(chr(ord(c)^clave) for c in texto)

msg = "hola"
clave = 23
cifrado = xor_cipher(msg, clave)
descifrado = xor_cipher(cifrado, clave)
print("Cifrado:", cifrado, "Descifrado:", descifrado)
```

---

## üîπ 6.5. Cifrado con Curvas El√≠pticas (ECC)

**Objetivo / Aplicaci√≥n:**
Proporcionar seguridad equivalente a RSA con claves mucho m√°s peque√±as.
Usa propiedades algebraicas de puntos sobre **curvas el√≠pticas** en cuerpos finitos.

**Fundamento te√≥rico:**
Basado en la dificultad del **problema del logaritmo discreto el√≠ptico (ECDLP)**.
**Complejidad:** O(log¬≥ n) ¬∑ **Clasificaci√≥n:** Asim√©trico / Matem√°tico / Determin√≠stico
**Origen:** **Koblitz y Miller (1985)**.

```mermaid
flowchart TD
A[Elegir curva el√≠ptica E] --> B[Seleccionar punto generador G]
B --> C[Generar clave privada k]
C --> D[Clave p√∫blica = k¬∑G]
D --> E[Cifrar/Descifrar con combinaciones de puntos]
```

```python
# Ejemplo conceptual (sin librer√≠as externas)
# Operaciones se simplifican para ilustrar la idea de punto * escalar
class ECPoint:
    def __init__(self, x, y): self.x, self.y = x, y
    def __mul__(self, k): return ECPoint(self.x*k, self.y*k)  # simplificado
    def __repr__(self): return f"({self.x},{self.y})"

G = ECPoint(2,3)
priv = 7
pub = G * priv
print("Clave p√∫blica simulada:", pub)
```

---

### ‚úÖ Cierre de la Secci√≥n 6

La criptograf√≠a moderna combina **matem√°tica avanzada** con **tecnolog√≠a pr√°ctica** para garantizar confidencialidad, autenticidad e integridad.
- **RSA / Diffie-Hellman / ECC:** cifrado asim√©trico y claves p√∫blicas.
- **AES / DES:** cifrado sim√©trico eficiente.
- **SHA / MD5:** resumen y verificaci√≥n de integridad.

---
