# üß© M√≥dulo 4: Estructuras de Datos y Algoritmos B√°sicos
## **Secci√≥n 2: B√∫squeda y Ordenamiento**

---

### üß† Introducci√≥n de la secci√≥n

En esta secci√≥n abordamos los **algoritmos fundamentales de b√∫squeda y ordenamiento**. Su correcta elecci√≥n impacta directamente en la **eficiencia temporal y espacial** de los sistemas. Presentamos cada algoritmo con: **objetivo**, **fundamento te√≥rico** (incluyendo complejidad y taxonom√≠a), **origen**, **diagrama Mermaid** del flujo l√≥gico y **ejemplo en Python** sin dependencias externas.

---

## üîé 2.1. B√∫squeda Binaria (Binary Search)

**Objetivo / Aplicaci√≥n:** Encontrar la posici√≥n de un elemento en una **lista ordenada** con el menor n√∫mero de comparaciones posible.

**Fundamento te√≥rico:** Parte el espacio de b√∫squeda en mitades iterativamente comparando el valor objetivo con el elemento medio.
**Complejidad temporal:** O(log n) (mejor: O(1)) ¬∑ **Complejidad espacial:** O(1) (iterativa) / O(log n) (recursiva)
**Clasificaci√≥n (taxonom√≠a):** B√∫squeda ¬∑ Determin√≠stico ¬∑ Divide y vencer√°s ¬∑ Requiere datos **ordenados**.
**Origen / Descubridor:** Documentado por **John Mauchly** (1946) y formalizado ampliamente en textos cl√°sicos de algoritmos.

```mermaid
flowchart TD
  A[Inicio] --> B[ini=0, fin=n-1]
  B --> C{ini <= fin?}
  C -->|No| D[No encontrado]
  C -->|S√≠| E[medio=(ini+fin)//2]
  E --> F{lista[medio] == x?}
  F -->|S√≠| G[Retornar medio]
  F -->|No y lista[medio] < x| H[ini = medio + 1]
  F -->|No y lista[medio] > x| I[fin = medio - 1]
  H --> C
  I --> C
```

```python
def binary_search(arr, x):
    ini, fin = 0, len(arr) - 1
    while ini <= fin:
        medio = (ini + fin) // 2
        if arr[medio] == x:
            return medio
        if arr[medio] < x:
            ini = medio + 1
        else:
            fin = medio - 1
    return -1

# Ejemplo
datos = [1, 3, 4, 7, 9, 11, 15]
print(binary_search(datos, 7))   # 3
print(binary_search(datos, 10))  # -1
```

---

## üîÅ 2.2. Bubble Sort

**Objetivo / Aplicaci√≥n:** Ordenar una lista realizando **intercambios de pares adyacentes** fuera de orden; √∫til con fines **did√°cticos** y listas muy peque√±as.

**Fundamento te√≥rico:** Repite pasadas burbujeando el m√°ximo (o m√≠nimo) hacia el extremo.
**Complejidad temporal:** O(n¬≤) (mejor: O(n) si se detectan pases sin swaps) ¬∑ **Complejidad espacial:** O(1)
**Clasificaci√≥n:** Ordenamiento por comparaciones ¬∑ In-place ¬∑ Estable (en variante cl√°sica) ¬∑ Determin√≠stico.
**Origen / Descubridor:** Popularizado en los a√±os 60 en literatura educativa de programaci√≥n.

```mermaid
flowchart TD
  A[Inicio] --> B[i=0..n-2]
  B --> C[j=0..n-i-2]
  C --> D{arr[j] > arr[j+1]?}
  D -->|S√≠| E[swap arr[j],arr[j+1]]
  D -->|No| F[Sigue]
  E --> C
  F --> C
```

```python
def bubble_sort(arr):
    n = len(arr)
    for i in range(n - 1):
        swapped = False
        for j in range(n - i - 1):
            if arr[j] > arr[j + 1]:
                arr[j], arr[j + 1] = arr[j + 1], arr[j]
                swapped = True
        if not swapped:  # optimizaci√≥n
            break
    return arr

print(bubble_sort([5,3,8,1,2]))
```

---

## üÉè 2.3. Selection Sort

**Objetivo / Aplicaci√≥n:** Ordenar seleccionando **el m√≠nimo** (o m√°ximo) y coloc√°ndolo en su posici√≥n final en cada iteraci√≥n.

**Fundamento te√≥rico:** Encuentra el m√≠nimo en la sublista restante y lo intercambia con la posici√≥n actual.
**Complejidad temporal:** O(n¬≤) ¬∑ **Complejidad espacial:** O(1)
**Clasificaci√≥n:** Ordenamiento por comparaciones ¬∑ In-place ¬∑ **No** estable (en implementaci√≥n est√°ndar) ¬∑ Determin√≠stico.
**Origen:** Descrito en textos cl√°sicos de programaci√≥n y an√°lisis de algoritmos (mediados del s. XX).

```mermaid
flowchart TD
  A[Inicio] --> B[i=0..n-1]
  B --> C[min=i; j=i+1..n-1]
  C --> D{arr[j] < arr[min]?}
  D -->|S√≠| E[min=j]
  D -->|No| F[contin√∫a]
  E --> C
  F --> G[swap arr[i],arr[min]]
  G --> B
```

```python
def selection_sort(arr):
    n = len(arr)
    for i in range(n):
        min_idx = i
        for j in range(i + 1, n):
            if arr[j] < arr[min_idx]:
                min_idx = j
        arr[i], arr[min_idx] = arr[min_idx], arr[i]
    return arr

print(selection_sort([5,3,8,1,2]))
```

---

## üÉú 2.4. Insertion Sort

**Objetivo / Aplicaci√≥n:** Ordenar insertando cada elemento en la **posici√≥n correcta** de la parte ya ordenada; muy eficiente para **listas peque√±as** o **casi ordenadas**.

**Fundamento te√≥rico:** Recorre y desplaza elementos mayores para insertar el actual en el hueco correcto.
**Complejidad temporal:** O(n¬≤) (mejor: O(n)) ¬∑ **Complejidad espacial:** O(1)
**Clasificaci√≥n:** Ordenamiento por comparaciones ¬∑ In-place ¬∑ Estable ¬∑ Determin√≠stico.
**Origen:** Ense√±ado tradicionalmente como analog√≠a a **ordenar cartas**.

```mermaid
flowchart TD
  A[Inicio] --> B[i=1..n-1]
  B --> C[key=arr[i]; j=i-1]
  C --> D{j>=0 y arr[j]>key?}
  D -->|S√≠| E[arr[j+1]=arr[j]; j--]
  D -->|No| F[arr[j+1]=key]
  E --> D
  F --> B
```

```python
def insertion_sort(arr):
    for i in range(1, len(arr)):
        key = arr[i]
        j = i - 1
        while j >= 0 and arr[j] > key:
            arr[j + 1] = arr[j]
            j -= 1
        arr[j + 1] = key
    return arr

print(insertion_sort([5,3,8,1,2]))
```

---

## üîÄ 2.5. Merge Sort

**Objetivo / Aplicaci√≥n:** Ordenar eficientemente mediante **divide y vencer√°s**, garantizando **estabilidad**.

**Fundamento te√≥rico:** Divide la lista en mitades, ordena recursivamente y **fusiona** dos listas ordenadas.
**Complejidad temporal:** O(n log n) ¬∑ **Complejidad espacial:** O(n)
**Clasificaci√≥n:** Ordenamiento por comparaciones ¬∑ No in-place (cl√°sico) ¬∑ Estable ¬∑ Determin√≠stico ¬∑ Divide y vencer√°s.
**Origen:** John von Neumann (1945).

```mermaid
flowchart TD
  A[Lista] --> B[Dividir en mitades]
  B --> C[Ordenar mitad izquierda]
  B --> D[Ordenar mitad derecha]
  C --> E[Fusionar]
  D --> E[Fusionar]
  E --> F[Lista ordenada]
```

```python
def merge(left, right):
    i = j = 0
    out = []
    while i < len(left) and j < len(right):
        if left[i] <= right[j]:
            out.append(left[i]); i += 1
        else:
            out.append(right[j]); j += 1
    out.extend(left[i:]); out.extend(right[j:])
    return out

def merge_sort(arr):
    if len(arr) <= 1:
        return arr
    mid = len(arr)//2
    return merge(merge_sort(arr[:mid]), merge_sort(arr[mid:]))

print(merge_sort([5,3,8,1,2]))
```

---

## ‚ö° 2.6. Quick Sort

**Objetivo / Aplicaci√≥n:** Ordenar en promedio en **O(n log n)** con bajo overhead y buena localidad de cach√©.

**Fundamento te√≥rico:** Selecciona un **pivote** y particiona en menores/iguales/mayores, aplicando recursi√≥n.
**Complejidad temporal:** Promedio O(n log n); peor caso O(n¬≤) ¬∑ **Complejidad espacial:** O(log n) (profundidad de pila promedio)
**Clasificaci√≥n:** Ordenamiento por comparaciones ¬∑ No estable (habitual) ¬∑ In-place (en versi√≥n Lomuto/Hoare) ¬∑ Divide y vencer√°s.
**Origen:** Tony Hoare (1959).

```mermaid
flowchart TD
  A[Inicio] --> B{n<=1?}
  B -->|S√≠| C[Retorna]
  B -->|No| D[Elegir pivote]
  D --> E[Particionar < = >]
  E --> F[QuickSort(izq)]
  E --> G[QuickSort(der)]
  F --> H[Concatenar izq+pivotes+der]
  G --> H
```

```python
def quicksort(arr):
    if len(arr) <= 1:
        return arr
    p = arr[len(arr)//2]
    left  = [x for x in arr if x < p]
    mid   = [x for x in arr if x == p]
    right = [x for x in arr if x > p]
    return quicksort(left) + mid + quicksort(right)

print(quicksort([5,3,8,1,2,7,4]))
```

---

## ‚õ∞Ô∏è 2.7. Heap Sort

**Objetivo / Aplicaci√≥n:** Ordenar utilizando un **heap binario** (m√°ximo o m√≠nimo).

**Fundamento te√≥rico:** Construye un heap, luego **extrae** repetidamente el elemento ra√≠z y lo coloca al final.
**Complejidad temporal:** O(n log n) ¬∑ **Complejidad espacial:** O(1) (in-place)
**Clasificaci√≥n:** Ordenamiento por comparaciones ¬∑ In-place ¬∑ No estable ¬∑ Estructuras de prioridad.
**Origen:** J. W. J. Williams (1964); optimizado por Floyd (1964).

```mermaid
flowchart TD
  A[Inicio] --> B[Construir heap]
  B --> C[i=n-1..1]
  C --> D[swap arr[0], arr[i]]
  D --> E[heapify(0, i)]
  E --> C
```

```python
def heapify(arr, n, i):
    largest = i
    l, r = 2*i + 1, 2*i + 2
    if l < n and arr[l] > arr[largest]:
        largest = l
    if r < n and arr[r] > arr[largest]:
        largest = r
    if largest != i:
        arr[i], arr[largest] = arr[largest], arr[i]
        heapify(arr, n, largest)

def heap_sort(arr):
    n = len(arr)
    # construir heap
    for i in range(n//2 - 1, -1, -1):
        heapify(arr, n, i)
    # extraer
    for i in range(n-1, 0, -1):
        arr[0], arr[i] = arr[i], arr[0]
        heapify(arr, i, 0)
    return arr

print(heap_sort([5,3,8,1,2,7,4]))
```

---

## üßÆ 2.8. Counting Sort (Enteros no negativos, rango acotado)

**Objetivo / Aplicaci√≥n:** Ordenar **sin comparaciones** cuando los valores son enteros en un **rango conocido y peque√±o**.

**Fundamento te√≥rico:** Cuenta ocurrencias de cada valor y reconstruye la secuencia ordenada por **acumulaci√≥n de frecuencias**.
**Complejidad temporal:** O(n + k) ¬∑ **Complejidad espacial:** O(k) (k = rango)
**Clasificaci√≥n:** Ordenamiento incremental ¬∑ No comparativo ¬∑ Estable (si se implementa con acumulaci√≥n) ¬∑ Determin√≠stico.
**Origen:** Aparece en literatura de mediados del s. XX; base de Radix Sort.

```mermaid
flowchart TD
  A[Inicio] --> B[Crear conteo de tama√±o k]
  B --> C[Contar ocurrencias]
  C --> D[Acumular conteos]
  D --> E[Construir salida estable]
  E --> F[Retornar]
```

```python
def counting_sort(arr, k):
    count = [0]*(k+1)
    for x in arr:
        count[x] += 1
    # acumulado para estabilidad
    for i in range(1, k+1):
        count[i] += count[i-1]
    out = [0]*len(arr)
    for x in reversed(arr):
        count[x] -= 1
        out[count[x]] = x
    return out

print(counting_sort([4,2,2,8,3,3,1], k=8))
```

---

## üî¢ 2.9. Radix Sort (Base 10, enteros no negativos)

**Objetivo / Aplicaci√≥n:** Ordenar **no comparativamente** procesando d√≠gito a d√≠gito (LSB‚ÜíMSB), apoy√°ndose en un m√©todo estable (p. ej., Counting Sort).

**Fundamento te√≥rico:** Ordena por cada posici√≥n de d√≠gito usando un ordenamiento **estable**, garantizando que el orden por d√≠gitos previos se conserve.
**Complejidad temporal:** O(d¬∑(n + b)) donde d= #d√≠gitos, b= base (10) ¬∑ **Complejidad espacial:** O(n + b)
**Clasificaci√≥n:** Ordenamiento no comparativo ¬∑ Estable ¬∑ Determin√≠stico.
**Origen:** Desarrollos de la era de tarjetas perforadas; formalizado en literatura de procesamiento num√©rico.

```mermaid
flowchart TD
  A[Inicio] --> B[exp=1]
  B --> C{max/exp > 0?}
  C -->|No| D[Fin]
  C -->|S√≠| E[Counting por d√≠gito (estable)]
  E --> F[exp *= 10]
  F --> C
```

```python
def counting_by_digit(arr, exp, base=10):
    count = [0]*base
    out = [0]*len(arr)
    for x in arr:
        idx = (x // exp) % base
        count[idx] += 1
    for i in range(1, base):
        count[i] += count[i-1]
    for x in reversed(arr):
        idx = (x // exp) % base
        count[idx] -= 1
        out[count[idx]] = x
    return out

def radix_sort(arr):
    if not arr:
        return arr
    m = max(arr)
    exp = 1
    out = arr[:]
    while m // exp > 0:
        out = counting_by_digit(out, exp, 10)
        exp *= 10
    return out

print(radix_sort([170,45,75,90,802,24,2,66]))
```

---

### ‚úÖ Cierre de la secci√≥n 2

- **B√∫squeda:** Binary Search reduce el espacio en potencias de 2 ‚Üí **O(log n)**, requisito: datos **ordenados**.
- **Ordenamiento:** elegir seg√∫n **n**, **distribuci√≥n**, **estabilidad** y **memoria**. Para casos generales: **Merge/Quick/Heap**; para enteros acotados: **Counting/Radix**; para conjuntos peque√±os o casi ordenados: **Insertion**.

---
