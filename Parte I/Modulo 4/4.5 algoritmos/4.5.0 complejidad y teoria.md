# üß© M√≥dulo 4: Estructuras de Datos y Algoritmos B√°sicos
## **Secci√≥n 0: Algoritmos Te√≥ricos y Complejidad**

---

### üß† Introducci√≥n General

La **teor√≠a de la complejidad algor√≠tmica** estudia cu√°n eficiente es un algoritmo en t√©rminos de **tiempo de ejecuci√≥n** y **uso de memoria**.
Permite comparar estrategias de resoluci√≥n y estimar su escalabilidad al crecer el tama√±o de los datos.

---

## üîπ 0.1. Complejidad Algor√≠tmica (Big O, Œ©, Œò)

**Objetivo / Aplicaci√≥n:**
Describir el comportamiento asint√≥tico de un algoritmo seg√∫n el tama√±o de entrada `n`.

- **O (Big O):** cota superior (peor caso).
- **Œ© (Omega):** cota inferior (mejor caso).
- **Œò (Theta):** cota ajustada (caso promedio).

| Complejidad | Ejemplo t√≠pico | Descripci√≥n |
|--------------|----------------|--------------|
| O(1) | Acceso en arreglo | Tiempo constante |
| O(log n) | B√∫squeda binaria | Crece lentamente |
| O(n) | Recorrido de lista | Lineal |
| O(n log n) | MergeSort | Eficiente |
| O(n¬≤) | BubbleSort | Cuadr√°tica |
| O(2‚Åø) | Backtracking | Exponencial |

```mermaid
graph LR
A[Entrada peque√±a] -->|O(n)| B[Crecimiento lineal]
A -->|O(n¬≤)| C[Crecimiento cuadr√°tico]
A -->|O(2‚Åø)| D[Crecimiento exponencial]
```

```python
import time

def ejemplo_complejidad(n):
    start = time.time()
    total = sum(i for i in range(n))
    print("Tiempo:", round(time.time()-start,6), "seg")
ejemplo_complejidad(10**6)
```

---

## üîπ 0.2. Backtracking (B√∫squeda Exhaustiva con Retroceso)

**Objetivo / Aplicaci√≥n:**
Resolver problemas combinatorios explorando todas las posibilidades, **retrocediendo** cuando una soluci√≥n parcial no puede completarse.

**Fundamento te√≥rico:**
Construye soluciones paso a paso y retrocede al detectar inconsistencias.
**Complejidad:** Exponencial en el peor caso O(k‚Åø) ¬∑ **Clasificaci√≥n:** Exacto / Determin√≠stico
**Ejemplo:** Sudoku, N-reinas, combinaciones v√°lidas.

```mermaid
flowchart TD
A[Inicio] --> B[Explorar opci√≥n]
B --> C{Es v√°lida?}
C -->|S√≠| D{Es soluci√≥n completa?}
C -->|No| E[Retroceder]
D -->|S√≠| F[Guardar soluci√≥n]
D -->|No| B
```

```python
def backtrack(sol, nums):
    if len(sol) == len(nums):
        print(sol)
        return
    for n in nums:
        if n not in sol:
            backtrack(sol + [n], nums)

backtrack([], [1,2,3])
```

---

## üîπ 0.3. Branch and Bound (Ramificaci√≥n y Poda)

**Objetivo / Aplicaci√≥n:**
Optimizar la b√∫squeda de soluciones descartando ramas que no pueden mejorar la mejor soluci√≥n actual.
Muy usado en **optimizaci√≥n combinatoria** (p. ej., problema del viajante).

**Fundamento te√≥rico:**
Expande ramas del √°rbol de b√∫squeda y las **poda** si superan un l√≠mite conocido (bound).
**Complejidad:** Exponencial en general ¬∑ **Clasificaci√≥n:** Exacto / Optimizaci√≥n
**Origen:** **Little, Murty, Sweeney y Karel (1963)**.

```mermaid
flowchart TD
A[Inicio] --> B[Generar nodo ra√≠z]
B --> C[Expandir nodo actual]
C --> D[Evaluar l√≠mite inferior]
D --> E{Supera mejor soluci√≥n?}
E -->|S√≠| F[Poda rama]
E -->|No| G[Explorar hijos]
```

```python
def branch_and_bound(nodos, mejor=float("inf")):
    for nodo in nodos:
        if nodo >= mejor:
            continue
        if nodo == 7:
            mejor = min(mejor, nodo)
        else:
            mejor = branch_and_bound([nodo+1, nodo+2], mejor)
    return mejor

print("Mejor valor encontrado:", branch_and_bound([0]))
```

---

## üîπ 0.4. Programaci√≥n Din√°mica

**Objetivo / Aplicaci√≥n:**
Dividir un problema en **subproblemas solapados**, resolviendo cada uno una vez y reutilizando sus resultados.
Se aplica en optimizaci√≥n, secuencias, rutas, etc.

**Fundamento te√≥rico:**
Basado en la **recurrencia** y **memorizaci√≥n** de soluciones parciales.
**Complejidad:** O(n¬∑m) ¬∑ **Clasificaci√≥n:** Determin√≠stico / Optimizaci√≥n / Recursivo
**Origen:** **Richard Bellman (1950s)**.

```mermaid
flowchart TD
A[Problema grande] --> B[Dividir en subproblemas]
B --> C[Resolver subproblemas menores]
C --> D[Almacenar resultados (memo)]
D --> E[Combinar resultados parciales]
```

### Ejemplo: Fibonacci con memorizaci√≥n

```python
memo = {}
def fib(n):
    if n in memo:
        return memo[n]
    if n <= 1:
        return n
    memo[n] = fib(n-1) + fib(n-2)
    return memo[n]

print("Fibonacci(10) =", fib(10))
```

---

### Ejemplo: Problema de la Mochila (0/1 Knapsack)

```python
def knapsack(pesos, valores, W):
    n = len(pesos)
    dp = [[0]*(W+1) for _ in range(n+1)]
    for i in range(1,n+1):
        for w in range(W+1):
            if pesos[i-1] <= w:
                dp[i][w] = max(dp[i-1][w], valores[i-1]+dp[i-1][w-pesos[i-1]])
            else:
                dp[i][w] = dp[i-1][w]
    return dp[n][W]

print("Valor m√°ximo:", knapsack([2,3,4],[4,5,6],5))
```

---

## üîπ 0.5. Divide y Vencer√°s

**Objetivo / Aplicaci√≥n:**
Resolver un problema grande dividi√©ndolo en **subproblemas independientes**, resolvi√©ndolos y combinando los resultados.

**Fundamento te√≥rico:**
Divide ‚Üí Resuelve ‚Üí Combina.
Ejemplos: MergeSort, QuickSort, FFT.
**Complejidad:** O(n log n) (en casos balanceados) ¬∑ **Clasificaci√≥n:** Recursivo / Determin√≠stico

```mermaid
flowchart TD
A[Problema grande] --> B[Dividir en subproblemas]
B --> C[Resolver subproblemas recursivamente]
C --> D[Combinar resultados]
D --> E[Soluci√≥n final]
```

```python
def merge_sort(arr):
    if len(arr) <= 1: return arr
    mid = len(arr)//2
    izq = merge_sort(arr[:mid])
    der = merge_sort(arr[mid:])
    return sorted(izq + der)

print(merge_sort([5,3,8,1,2]))
```

---

## üîπ 0.6. Algoritmos Probabil√≠sticos (Monte Carlo / Las Vegas)

**Objetivo / Aplicaci√≥n:**
Resolver problemas complejos mediante **aleatoriedad controlada**.
- **Monte Carlo:** puede devolver respuestas incorrectas, pero r√°pido.
- **Las Vegas:** siempre correcto, pero tiempo variable.

**Fundamento te√≥rico:**
Basados en **probabilidad y simulaci√≥n** (p. ej., integraci√≥n, optimizaci√≥n, juegos).
**Complejidad:** Depende de distribuci√≥n aleatoria ¬∑ **Clasificaci√≥n:** Probabil√≠stico / Aproximado

```mermaid
flowchart TD
A[Generar muestra aleatoria] --> B[Evaluar funci√≥n objetivo]
B --> C[Promediar resultados]
C --> D[Estimar soluci√≥n con probabilidad de error]
```

### Ejemplo Monte Carlo: estimar œÄ

```python
import random, math

def montecarlo_pi(n=10000):
    dentro = 0
    for _ in range(n):
        x,y = random.random(), random.random()
        if x*x + y*y <= 1:
            dentro += 1
    return 4*dentro/n

print("Estimaci√≥n de œÄ:", montecarlo_pi())
```

---

### ‚úÖ Cierre de la Secci√≥n 10

Los **algoritmos te√≥ricos** constituyen la base del pensamiento algor√≠tmico moderno:
- **Backtracking / Branch & Bound:** b√∫squeda exhaustiva y optimizaci√≥n.
- **Programaci√≥n Din√°mica:** reutilizaci√≥n eficiente.
- **Divide & Vencer√°s:** resoluci√≥n modular.
- **Probabil√≠sticos:** soluciones r√°pidas con incertidumbre controlada.

La **teor√≠a de la complejidad** permite entender sus l√≠mites y elegir la estrategia m√°s adecuada para cada tipo de problema.

---
