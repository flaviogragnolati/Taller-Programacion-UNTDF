# üß© M√≥dulo 4: Estructuras de Datos y Algoritmos B√°sicos

## **Tema 4.2: Pilas, Colas, Heaps, Listas Enlazadas, Hash Maps y Grafos**

---

### üß† Introducci√≥n

Las **estructuras de datos** son formas organizadas de almacenar y manipular informaci√≥n dentro de un programa.
Permiten representar datos del mundo real y ejecutar operaciones sobre ellos de manera eficiente.

En t√©rminos generales, las estructuras de datos definen **c√≥mo los datos se almacenan en memoria**, **c√≥mo se accede a ellos**, y **qu√© operaciones son posibles**.

---

### üîπ Clasificaci√≥n de las estructuras de datos

Las estructuras de datos pueden clasificarse seg√∫n distintos criterios:

| Criterio | Tipos | Descripci√≥n |
|-----------|--------|-------------|
| **Seg√∫n su naturaleza** | **Est√°ticas** y **Din√°micas** | Las **est√°ticas** (como listas o arreglos fijos) tienen tama√±o determinado en el momento de su creaci√≥n. Las **din√°micas** (como pilas, colas o listas enlazadas) pueden crecer o reducirse durante la ejecuci√≥n. |
| **Seg√∫n su forma** | **Lineales** y **No lineales** | Las **lineales** (listas, colas, pilas) disponen los datos en una secuencia. Las **no lineales** (√°rboles, grafos) representan relaciones jer√°rquicas o de conexi√≥n m√∫ltiple entre los elementos. |

---

### üîπ Analog√≠a con vectores, matrices y tensores

Podemos relacionar estas estructuras con conceptos matem√°ticos:

| Concepto | Representaci√≥n en Python | Ejemplo | Descripci√≥n |
|-----------|--------------------------|----------|--------------|
| **Vector (1D)** | Lista o tupla | `[1, 2, 3]` | Secuencia lineal de elementos. |
| **Matriz (2D)** | Lista de listas | `[[1,2],[3,4]]` | Estructura bidimensional (filas y columnas). |
| **Tensor (nD)** | Listas anidadas | `[[[1,2],[3,4]], [[5,6],[7,8]]]` | Estructura multidimensional (usada en IA y c√°lculos cient√≠ficos). |

Estas estructuras m√°s complejas pueden construirse utilizando combinaciones de las estructuras b√°sicas que veremos a continuaci√≥n.

---

## üîπ 1. Pilas (Stacks)

Una **pila** es una estructura **lineal din√°mica** basada en el principio **LIFO** (*Last In, First Out*).
El √∫ltimo elemento agregado es el primero en salir.

üì¶ **Ejemplo real:** una pila de platos o una torre de cartas.

### üìò Ejemplo:

```python
class Pila:
    def __init__(self):
        self.items = []

    def apilar(self, elemento):
        self.items.append(elemento)

    def desapilar(self):
        if not self.esta_vacia():
            return self.items.pop()

    def ver_tope(self):
        if not self.esta_vacia():
            return self.items[-1]

    def esta_vacia(self):
        return len(self.items) == 0


# Uso
p = Pila()
p.apilar(1)
p.apilar(2)
p.apilar(3)
print("Tope:", p.ver_tope())  # 3
p.desapilar()
print("Pila actual:", p.items)  # [1, 2]
```

---

## üîπ 2. Colas (Queues)

Una **cola** es una estructura **lineal din√°mica** basada en el principio **FIFO** (*First In, First Out*).
El primer elemento en ingresar es el primero en salir.

üì¶ **Ejemplo real:** una fila de personas esperando en un mostrador.

### üìò Ejemplo:

```python
class Cola:
    def __init__(self):
        self.items = []

    def encolar(self, elemento):
        self.items.append(elemento)

    def desencolar(self):
        if not self.esta_vacia():
            return self.items.pop(0)

    def ver_primero(self):
        if not self.esta_vacia():
            return self.items[0]

    def esta_vacia(self):
        return len(self.items) == 0


# Uso
c = Cola()
c.encolar("A")
c.encolar("B")
c.encolar("C")
print("Primero:", c.ver_primero())  # A
c.desencolar()
print("Cola actual:", c.items)  # ['B', 'C']
```

---

## üîπ 3. Heaps (Mont√≠culos)

Un **heap** es una estructura **no lineal** que mantiene un **orden parcial** entre sus elementos.
En un **heap m√≠nimo**, el valor m√°s peque√±o siempre se encuentra en la ra√≠z.
Aunque Python provee `heapq`, aqu√≠ implementamos uno b√°sico manualmente.

### üìò Ejemplo de heap m√≠nimo:

```python
class HeapMinimo:
    def __init__(self):
        self.heap = []

    def insertar(self, valor):
        self.heap.append(valor)
        self._flotar(len(self.heap) - 1)

    def extraer_minimo(self):
        if len(self.heap) == 0:
            return None
        minimo = self.heap[0]
        ultimo = self.heap.pop()
        if self.heap:
            self.heap[0] = ultimo
            self._hundir(0)
        return minimo

    def _flotar(self, i):
        padre = (i - 1) // 2
        if i > 0 and self.heap[i] < self.heap[padre]:
            self.heap[i], self.heap[padre] = self.heap[padre], self.heap[i]
            self._flotar(padre)

    def _hundir(self, i):
        hijo_izq = 2 * i + 1
        hijo_der = 2 * i + 2
        menor = i
        if hijo_izq < len(self.heap) and self.heap[hijo_izq] < self.heap[menor]:
            menor = hijo_izq
        if hijo_der < len(self.heap) and self.heap[hijo_der] < self.heap[menor]:
            menor = hijo_der
        if menor != i:
            self.heap[i], self.heap[menor] = self.heap[menor], self.heap[i]
            self._hundir(menor)


# Uso
h = HeapMinimo()
for n in [5, 3, 8, 1, 2]:
    h.insertar(n)

print("Heap interno:", h.heap)
print("Elemento m√≠nimo:", h.extraer_minimo())
```

---

## üîπ 4. Listas enlazadas (Linked Lists)

Una **lista enlazada** est√° formada por **nodos** conectados entre s√≠.
Cada nodo contiene un **valor** y una **referencia al siguiente nodo**.

üì¶ **Ejemplo real:** una cadena de vagones de tren.

### üìò Ejemplo:

```python
class Nodo:
    def __init__(self, valor):
        self.valor = valor
        self.siguiente = None

class ListaEnlazada:
    def __init__(self):
        self.cabeza = None

    def agregar(self, valor):
        nuevo = Nodo(valor)
        if not self.cabeza:
            self.cabeza = nuevo
        else:
            actual = self.cabeza
            while actual.siguiente:
                actual = actual.siguiente
            actual.siguiente = nuevo

    def mostrar(self):
        actual = self.cabeza
        while actual:
            print(actual.valor, end=" -> ")
            actual = actual.siguiente
        print("None")


# Uso
lista = ListaEnlazada()
lista.agregar(10)
lista.agregar(20)
lista.agregar(30)
lista.mostrar()
```

---

## üîπ 5. Hash Maps (Tablas Hash)

Un **Hash Map** o **tabla hash** almacena pares **clave ‚Üí valor**.  
Se basa en una **funci√≥n hash** que convierte la clave en una posici√≥n dentro de una tabla.

üì¶ **Ejemplo real:** una agenda telef√≥nica donde se busca por nombre.

### üìò Ejemplo:

```python
class HashMap:
    def __init__(self, tama√±o=10):
        self.tama√±o = tama√±o
        self.tabla = [None] * tama√±o

    def _hash(self, clave):
        return hash(clave) % self.tama√±o

    def agregar(self, clave, valor):
        indice = self._hash(clave)
        if self.tabla[indice] is None:
            self.tabla[indice] = []
        for par in self.tabla[indice]:
            if par[0] == clave:
                par = (clave, valor)
                return
        self.tabla[indice].append((clave, valor))

    def obtener(self, clave):
        indice = self._hash(clave)
        if self.tabla[indice] is not None:
            for par in self.tabla[indice]:
                if par[0] == clave:
                    return par[1]
        return None


# Uso
h = HashMap()
h.agregar("ana", 25)
h.agregar("luis", 30)
print("Edad de ana:", h.obtener("ana"))
```

---

## üîπ 6. Grafos

Un **grafo** es una estructura **no lineal** que representa **nodos (v√©rtices)** conectados por **aristas (edges)**.  
Puede ser **dirigido o no dirigido**, y con **pesos o sin ellos**.

üì¶ **Ejemplo real:** una red de transporte o conexiones entre computadoras.

### üìò Ejemplo:

```python
class Grafo:
    def __init__(self):
        self.vertices = {}

    def agregar_vertice(self, v):
        if v not in self.vertices:
            self.vertices[v] = []

    def agregar_arista(self, v1, v2):
        if v1 in self.vertices and v2 in self.vertices:
            self.vertices[v1].append(v2)
            self.vertices[v2].append(v1)

    def mostrar(self):
        for v, adyacentes in self.vertices.items():
            print(v, "->", adyacentes)


# Uso
g = Grafo()
for v in ["A", "B", "C", "D"]:
    g.agregar_vertice(v)

g.agregar_arista("A", "B")
g.agregar_arista("A", "C")
g.agregar_arista("B", "D")
g.mostrar()
```

---

## üìö Resumen comparativo

| Estructura | Tipo | Orden | Acceso | Duplicados | Ejemplo t√≠pico |
|-------------|-------|--------|----------|-------------|----------------|
| **Pila** | Lineal | LIFO | Secuencial | S√≠ | Undo, navegaci√≥n |
| **Cola** | Lineal | FIFO | Secuencial | S√≠ | Turnos, buffers |
| **Heap** | No lineal | Parcial | Ra√≠z m√≠nima/m√°xima | S√≠ | Prioridades |
| **Lista enlazada** | Lineal din√°mica | Secuencial | Por nodo | S√≠ | Inserciones r√°pidas |
| **Hash Map** | Asociativa | No ordenada | Por clave | No (en claves) | Diccionarios |
| **Grafo** | No lineal | Conectado | Por v√©rtices | N/A | Redes, caminos |

---

## üìñ Recursos y referencias

- Cormen, T. H. et al. (2009). *Introduction to Algorithms*. MIT Press.
- Goodrich, M. T. & Tamassia, R. (2015). *Data Structures and Algorithms in Python*. Wiley.
- Downey, A. (2015). *Think Python*. Green Tea Press.
- Documentaci√≥n oficial de Python: [https://docs.python.org/3/tutorial/datastructures.html](https://docs.python.org/3/tutorial/datastructures.html)
- Tutorial interactivo: [https://www.programiz.com/python-programming/data-structures](https://www.programiz.com/python-programming/data-structures)

---