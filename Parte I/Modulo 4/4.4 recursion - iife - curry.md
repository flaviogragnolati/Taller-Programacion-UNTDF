# üß© M√≥dulo 4: Estructuras de Datos y Algoritmos B√°sicos

## **Tema 4.4: Recursi√≥n, Funciones Inmediatamente Invocadas (IIFE) y Currying**

---

### üß† Introducci√≥n

En este tema abordaremos tres conceptos esenciales del pensamiento algor√≠tmico y funcional en Python:

1. **La recursi√≥n**, como t√©cnica para resolver problemas mediante la autollamada de funciones.
2. **Las funciones inmediatamente invocadas (IIFE)**, una forma de ejecutar c√≥digo en un contexto aislado.
3. **El currying**, una t√©cnica de composici√≥n funcional que permite construir funciones m√°s flexibles y reutilizables.

Estos conceptos se utilizan ampliamente en programaci√≥n funcional, dise√±o de algoritmos y optimizaci√≥n del flujo de datos.

---

## üîπ 1. Recursi√≥n

La **recursi√≥n** ocurre cuando una funci√≥n **se llama a s√≠ misma** para resolver una versi√≥n m√°s simple del mismo problema.  
Se basa en dos principios:

1. **Caso base:** condici√≥n que detiene la recursi√≥n.  
2. **Caso recursivo:** parte que contin√∫a el proceso reduciendo el problema.

---

### üìò Ejemplo 1: Factorial de un n√∫mero

El factorial de un n√∫mero `n` (notaci√≥n `n!`) se define como:

```
n! = n √ó (n-1) √ó (n-2) √ó ... √ó 1
```

Y puede expresarse recursivamente como:
```
n! = n √ó (n-1)!
```

```python
def factorial(n):
    if n == 0:
        return 1  # Caso base
    else:
        return n * factorial(n - 1)  # Caso recursivo

print(factorial(5))  # 120
```

---

### üìò Ejemplo 2: Fibonacci recursivo

La secuencia de Fibonacci se define como:
```
F(0) = 0
F(1) = 1
F(n) = F(n-1) + F(n-2)
```

```python
def fibonacci(n):
    if n <= 1:
        return n
    return fibonacci(n - 1) + fibonacci(n - 2)

for i in range(6):
    print(f"F({i}) = {fibonacci(i)}")
```

üì§ **Salida:**
```
F(0) = 0
F(1) = 1
F(2) = 1
F(3) = 2
F(4) = 3
F(5) = 5
```

---

### üí° Ventajas y desventajas

| Ventajas | Desventajas |
|-----------|--------------|
| Simplifica la escritura de algunos algoritmos. | Puede consumir m√°s memoria (llamadas anidadas). |
| Facilita la lectura en estructuras jer√°rquicas (√°rboles, grafos). | Riesgo de recursi√≥n infinita si no se define un caso base. |

---

### üìò Ejemplo 3: Recorrer una estructura anidada

```python
def recorrer_lista(lista):
    for elemento in lista:
        if isinstance(elemento, list):
            recorrer_lista(elemento)
        else:
            print(elemento)

datos = [1, [2, 3], [4, [5, 6]]]
recorrer_lista(datos)
```

üì§ **Salida:**
```
1
2
3
4
5
6
```

---

## üîπ 2. Funciones Inmediatamente Invocadas (IIFE)

Una **IIFE** (*Immediately Invoked Function Expression*) es una funci√≥n que se **define y ejecuta en el mismo momento**.

Este patr√≥n se utiliza para:
- Crear un **√°mbito local** (evitar variables globales).
- Ejecutar c√≥digo ‚Äúaut√≥nomo‚Äù.
- Simular comportamientos funcionales de encapsulaci√≥n.

En Python, no existen IIFE ‚Äúnativas‚Äù como en JavaScript, pero pueden emularse f√°cilmente.

---

### üìò Ejemplo 1: IIFE en Python

```python
resultado = (lambda x, y: x + y)(3, 4)
print(resultado)  # 7
```

Aqu√≠ definimos una funci√≥n an√≥nima (`lambda`) y la ejecutamos inmediatamente con los argumentos `(3, 4)`.

---

### üìò Ejemplo 2: Bloque aislado de inicializaci√≥n

```python
(lambda: (
    print("Inicializando entorno..."),
    print("Cargando configuraciones..."),
    print("Listo.")
))()
```

üì§ **Salida:**
```
Inicializando entorno...
Cargando configuraciones...
Listo.
```

üí° Este patr√≥n puede utilizarse para ejecutar inicializaciones o pruebas r√°pidas sin dejar variables globales en memoria.

---

## üîπ 3. Currying

El **currying** es una t√©cnica que transforma una funci√≥n que recibe varios argumentos en una **secuencia de funciones**, donde cada una recibe un argumento y devuelve otra funci√≥n.

Permite:
- Crear funciones m√°s **reutilizables** y **componibles**.
- Aplicar **parcialmente** funciones (similar a `functools.partial`).

---

### üìò Ejemplo 1: Currying manual

```python
def sumar(a):
    def agregar(b):
        def finalizar(c):
            return a + b + c
        return finalizar
    return agregar

print(sumar(2)(3)(5))  # 10
```

üìñ Aqu√≠, cada funci√≥n devuelve otra funci√≥n que ‚Äúrecuerda‚Äù los par√°metros anteriores gracias al **encierro l√©xico (closure)**.

---

### üìò Ejemplo 2: Currying con lambdas

```python
sumar = lambda a: (lambda b: (lambda c: a + b + c))
print(sumar(1)(2)(3))  # 6
```

---

### üìò Ejemplo 3: Uso pr√°ctico ‚Äî generar funciones especializadas

```python
def multiplicar_por(factor):
    return lambda x: x * factor

duplicar = multiplicar_por(2)
triplicar = multiplicar_por(3)

print(duplicar(10))  # 20
print(triplicar(10)) # 30
```

üí° Este patr√≥n es muy √∫til en programaci√≥n funcional, donde se encadenan transformaciones sucesivas sobre datos.

---

## üîπ 4. Ejemplo integrador

Supongamos que queremos calcular la **suma factorial** de una lista de n√∫meros,  
pero cada n√∫mero ser√° procesado con una **funci√≥n currificada** y un **llamado recursivo**:

```python
# 1Ô∏è‚É£ Currying: funci√≥n factorial parcial
def factorial_curry():
    def factorial(n):
        if n == 0:
            return 1
        return n * factorial(n - 1)
    return factorial

# 2Ô∏è‚É£ IIFE: inicializar entorno
resultado = (lambda: (
    print("Calculando suma factorial..."),
    sum(factorial_curry()(n) for n in [1, 2, 3, 4])
))()

print("Resultado final:", resultado)
```

üì§ **Salida esperada:**
```
Calculando suma factorial...
Resultado final: 33
```

---

## üìö Resumen

| Concepto | Descripci√≥n | Palabra clave / patr√≥n | Ejemplo |
|-----------|--------------|-------------------------|----------|
| **Recursi√≥n** | Funci√≥n que se llama a s√≠ misma | `def f(): return f()` | `factorial(n)` |
| **IIFE** | Funci√≥n que se ejecuta al definirse | `(lambda ...)(args)` | `(lambda x: x*2)(5)` |
| **Currying** | Funci√≥n que devuelve otra funci√≥n | `lambda a: lambda b:` | `sumar(2)(3)` |

---

## üìñ Recursos y referencias

- *Think Python* ‚Äì Allen B. Downey, Cap√≠tulo 5 (*Recursion*).  
- *Fluent Python* ‚Äì Luciano Ramalho, O‚ÄôReilly (2022).  
- *Python Functional Programming Cookbook* ‚Äì Steven F. Lott.  
- Documentaci√≥n oficial de Python ‚Äì [https://docs.python.org/3/tutorial/controlflow.html#defining-functions](https://docs.python.org/3/tutorial/controlflow.html#defining-functions)  
- Art√≠culo: *Currying, Closures and Lambdas in Python* ‚Äì Real Python.

---