# üßÆ M√≥dulo 4: Estructuras de Datos y Algoritmos B√°sicos
## **Tema 4.6:** Complejidad (Big O) y Buenas Pr√°cticas de Rendimiento

---

### üéØ Objetivo del tema
Introducir los conceptos fundamentales de **complejidad algor√≠tmica** y **rendimiento**, enfoc√°ndose en las **buenas pr√°cticas** para optimizar el uso de **tiempo de ejecuci√≥n** y **memoria** en los programas.
M√°s que una mirada matem√°tica, se busca desarrollar el **criterio pr√°ctico** para elegir estrategias de implementaci√≥n m√°s eficientes.

---

## üß† 1. ¬øQu√© es la Complejidad?

La **complejidad algor√≠tmica** mide c√≥mo crece el uso de **recursos** (tiempo o memoria) de un algoritmo a medida que aumenta el tama√±o del problema.

- **Complejidad temporal:** cu√°nto tiempo tarda en ejecutarse un algoritmo.
- **Complejidad espacial:** cu√°nta memoria utiliza el algoritmo.

Estas medidas se expresan con la **notaci√≥n Big O (O grande)**, que describe el **comportamiento asint√≥tico** (a grandes rasgos, c√≥mo crece el costo a medida que el problema crece).

---

## ‚öôÔ∏è 2. Notaci√≥n Big O ‚Äî una visi√≥n simple

| Complejidad | Nombre com√∫n | Ejemplo t√≠pico |
|--------------|---------------|----------------|
| O(1) | Constante | Acceso a un elemento de una lista o diccionario |
| O(log n) | Logar√≠tmica | B√∫squeda binaria |
| O(n) | Lineal | Recorrer una lista completa |
| O(n log n) | Lineal-logar√≠tmica | Algoritmos de ordenamiento eficientes (MergeSort, QuickSort) |
| O(n¬≤) | Cuadr√°tica | Comparar todos con todos (burbujas, doble bucle) |
| O(2‚Åø) | Exponencial | Algoritmos recursivos no optimizados |
| O(n!) | Factorial | Permutaciones o combinaciones completas |

üìò **Ejemplo ilustrativo:**
Un algoritmo con complejidad O(n¬≤) se vuelve *100 veces m√°s lento* si duplicamos el tama√±o del problema.

---

## ‚ö° 3. Ejemplo cl√°sico: factorial

El c√°lculo del **factorial de un n√∫mero (n!)** es un ejemplo perfecto para analizar **tiempo y memoria**.

### üß© Implementaci√≥n recursiva simple

```python
def factorial(n):
    if n == 0:
        return 1
    return n * factorial(n - 1)

print(factorial(5))
```

- **Ventaja:** c√≥digo claro y corto.
- **Desventaja:** cada llamada crea un nuevo *frame* en memoria ‚Üí **uso factorial de memoria**.
- **Complejidad temporal:** O(n)
- **Complejidad espacial:** O(n) por el uso de la pila de llamadas.

---

### üîÅ Versi√≥n iterativa (mejor uso de memoria)

```python
def factorial_iterativo(n):
    resultado = 1
    for i in range(1, n + 1):
        resultado *= i
    return resultado
```

- **Ventaja:** uso constante de memoria (O(1)).
- **Mismo tiempo O(n)**, pero sin sobrecargar la pila.
- Ideal para valores grandes de `n`.

---

## üß± 4. Ejemplo de mejora con *cache* (memorizaci√≥n)

Algunos algoritmos repiten muchos c√°lculos innecesarios.
La **memorizaci√≥n** (cachear resultados previos) es una pr√°ctica clave para mejorar rendimiento.

### üê¢ Ejemplo: Fibonacci sin optimizaci√≥n

```python
def fib(n):
    if n <= 1:
        return n
    return fib(n-1) + fib(n-2)
```

- **Complejidad temporal:** O(2‚Åø)
- Muchas llamadas repiten los mismos c√°lculos.

---

### ‚ö° Con memorizaci√≥n

```python
from functools import lru_cache

@lru_cache(maxsize=None)
def fib_optimizado(n):
    if n <= 1:
        return n
    return fib_optimizado(n-1) + fib_optimizado(n-2)
```

Nota sobre `functools.lru_cache`:

- `lru_cache` es un decorador de la librer√≠a est√°ndar `functools` que a√±ade una cach√© en memoria para los resultados de la funci√≥n. Cuando la funci√≥n es llamada con unos mismos argumentos, el resultado previamente calculado se devuelve directamente desde la cach√© en lugar de recomputarse.
- El par√°metro `maxsize` controla cu√°ntas entradas conserva la cach√©; `maxsize=None` significa que la cach√© no tiene l√≠mite y puede crecer seg√∫n sea necesario, mientras que un entero (por ejemplo `128`) limita la memoria y aplica la pol√≠tica LRU (se eliminan las entradas menos recientemente usadas).
- Es especialmente √∫til para funciones "puras" (sin efectos secundarios) como `fib_optimizado`. Ten en cuenta que la cach√© permanece durante la vida del proceso; puedes limpiarla con `fib_optimizado.cache_clear()` o inspeccionarla con `fib_optimizado.cache_info()`.
- Internamente maneja bloqueo para seguridad en entornos multihilo en CPython, pero siempre es buena idea evaluar el uso de memoria cuando se activa una cach√©.

- **Complejidad temporal:** O(n)
- **Complejidad espacial:** O(n) (la cach√© almacena hasta n resultados en memoria; el uso real depende de `maxsize`)


üìå **Conclusi√≥n:**
Un peque√±o cambio de enfoque reduce el tiempo de ejecuci√≥n de manera *exponencial*.

---

## üí° 5. Buenas pr√°cticas de rendimiento

### üß† Pensar antes de codificar
- Analizar el tama√±o esperado de los datos.
- Evitar recorrer estructuras completas si no es necesario.
- Priorizar operaciones O(1) o O(log n) siempre que sea posible.

### ‚öôÔ∏è Estructuras de datos adecuadas
- Usar **diccionarios (hash maps)** en lugar de listas para b√∫squedas.
- Usar **sets** para verificar pertenencia r√°pida.
- Evitar conversiones o copias innecesarias de listas.

### üßπ Optimizaci√≥n de memoria
- Reutilizar variables.
- Preferir **generadores** (`yield`) en lugar de listas grandes.
- Liberar recursos cuando ya no se necesitan (`del`, cerrar archivos, etc.).

### üßÆ Precalcular y cachear
- Guardar resultados de c√°lculos costosos.
- Usar decoradores como `@lru_cache` o variables globales de cache.

### ‚è±Ô∏è Medir siempre
- Usar herramientas como `timeit` o m√≥dulos de *profiling* (`cProfile`) para medir el rendimiento real.
Ejemplo:

```python
import timeit
print(timeit.timeit("sum(range(1000000))", number=10))
```

---

## üîç 6. Conclusi√≥n final

Optimizar no siempre significa escribir c√≥digo m√°s corto o m√°s ‚Äúbonito‚Äù, sino **m√°s eficiente**.
Conocer la complejidad y aplicar buenas pr√°cticas de rendimiento nos permite:

- Reducir costos de c√≥mputo.
- Hacer sistemas m√°s escalables.
- Mejorar la experiencia del usuario.

üìò En palabras simples: *pensar c√≥mo resolver el problema, no solo c√≥mo escribir el c√≥digo.*

---

## üîó Recursos recomendados

- üìö **Big-O Cheat Sheet:** [https://www.bigocheatsheet.com/](https://www.bigocheatsheet.com/)
- üí° **Python `functools.lru_cache` doc:** [https://docs.python.org/3/library/functools.html#functools.lru_cache](https://docs.python.org/3/library/functools.html#functools.lru_cache)
- üß∞ **Profiling en Python:** [https://docs.python.org/3/library/profile.html](https://docs.python.org/3/library/profile.html)
- üéì **Video (YouTube):** ‚ÄúBig O Notation Explained ‚Äî Simply Explained‚Äù

---

**üëâ Pr√≥ximo tema sugerido:** Aplicaci√≥n pr√°ctica de optimizaci√≥n en algoritmos de b√∫squeda y ordenamiento.
