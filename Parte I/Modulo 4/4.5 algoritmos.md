# ğŸ§© MÃ³dulo 4: Estructuras de Datos y Algoritmos BÃ¡sicos

## **Tema 4.5: Algoritmos Fundamentales (BÃºsqueda y Ordenamiento)**

---

### ğŸ§  IntroducciÃ³n

Los **algoritmos fundamentales** constituyen la base del pensamiento computacional y de la eficiencia en la programaciÃ³n.
Entre ellos, los algoritmos de **bÃºsqueda** y **ordenamiento** son esenciales para el manejo eficiente de datos en estructuras como listas, arreglos o colecciones.

Antes de abordarlos, veamos quÃ© entendemos por **algoritmo**.

---

## ğŸ”¹ 0. Â¿QuÃ© es un algoritmo?

Un **algoritmo** es un **conjunto finito de pasos definidos y ordenados** que permiten resolver un problema o realizar una tarea especÃ­fica.
Cada paso describe **una acciÃ³n concreta**, y su ejecuciÃ³n debe conducir a un resultado en un tiempo finito.

En otras palabras, un algoritmo es una **receta o procedimiento** que, aplicado a una entrada (datos), produce una salida (resultado).

---

### ğŸ“˜ Ejemplo cotidiano: cocinar fideos

**Algoritmo en lenguaje natural:**
1. Llenar una olla con agua.
2. Colocar la olla sobre el fuego.
3. Esperar a que el agua hierva.
4. Agregar sal al agua.
5. Incorporar los fideos.
6. Revolver ocasionalmente.
7. Esperar el tiempo de cocciÃ³n indicado.
8. Colar los fideos.
9. Servir.

âœ… Este es un ejemplo de algoritmo **determinÃ­stico y secuencial**: cada paso depende del anterior y tiene un orden definido.

---

### ğŸ§© RepresentaciÃ³n grÃ¡fica del algoritmo

```mermaid
flowchart TD
    A[Llenar olla con agua] --> B[Colocar sobre el fuego]
    B --> C[Esperar a que hierva]
    C --> D[Agregar sal]
    D --> E[Agregar los fideos]
    E --> F[Revolver ocasionalmente]
    F --> G[Esperar el tiempo de cocciÃ³n]
    G --> H[Colar los fideos]
    H --> I[Servir]
```

---

## ğŸ”¹ 1. BÃºsqueda en estructuras de datos

El objetivo de un algoritmo de bÃºsqueda es **encontrar un elemento dentro de una colecciÃ³n** (lista, arreglo, etc.), o determinar que no existe.

---

### ğŸ“˜ 1.1. BÃºsqueda lineal

La **bÃºsqueda lineal** recorre todos los elementos de la lista **uno por uno** hasta encontrar el valor buscado.

âœ… **Ventaja:** funciona en listas no ordenadas.
âš ï¸ **Desventaja:** lenta para listas grandes.

```python
def busqueda_lineal(lista, valor):
    for i in range(len(lista)):
        if lista[i] == valor:
            return i  # Devuelve el Ã­ndice
    return -1  # No encontrado

datos = [10, 20, 30, 40, 50]
print(busqueda_lineal(datos, 30))  # 2
print(busqueda_lineal(datos, 99))  # -1
```

ğŸ“ˆ **Complejidad:**
- Peor caso: O(n)
- Mejor caso: O(1)
- Promedio: O(n/2)

---

### ğŸ“˜ 1.2. BÃºsqueda binaria

La **bÃºsqueda binaria** funciona **solo en listas ordenadas**.
Divide el rango de bÃºsqueda a la mitad en cada paso, descartando la mitad que no contiene el valor.

âœ… **Ventaja:** mucho mÃ¡s rÃ¡pida que la bÃºsqueda lineal.
âš ï¸ **Desventaja:** requiere una lista previamente ordenada.

```python
def busqueda_binaria(lista, valor):
    inicio = 0
    fin = len(lista) - 1

    while inicio <= fin:
        medio = (inicio + fin) // 2
        if lista[medio] == valor:
            return medio
        elif lista[medio] < valor:
            inicio = medio + 1
        else:
            fin = medio - 1
    return -1

datos = [10, 20, 30, 40, 50, 60, 70]
print(busqueda_binaria(datos, 40))  # 3
print(busqueda_binaria(datos, 15))  # -1
```

ğŸ“ˆ **Complejidad:**
- Peor caso: O(log n)
- Mejor caso: O(1)
- Promedio: O(log n)

---

## ğŸ”¹ 2. Algoritmos de ordenamiento

El **ordenamiento** permite organizar los elementos de una colecciÃ³n segÃºn algÃºn criterio (numÃ©rico, alfabÃ©tico, etc.).
Existen muchos mÃ©todos, cada uno con diferentes caracterÃ­sticas y eficiencias.

---

### ğŸ“˜ 2.1. Ordenamiento por burbuja (Bubble Sort)

Compara pares de elementos adyacentes e intercambia sus posiciones si estÃ¡n en el orden incorrecto.
Este proceso se repite hasta que toda la lista estÃ© ordenada.

```python
def bubble_sort(lista):
    n = len(lista)
    for i in range(n - 1):
        for j in range(n - i - 1):
            if lista[j] > lista[j + 1]:
                lista[j], lista[j + 1] = lista[j + 1], lista[j]
    return lista

print(bubble_sort([5, 3, 8, 1, 2]))  # [1, 2, 3, 5, 8]
```

ğŸ“ˆ **Complejidad:** O(nÂ²)

---

### ğŸ“˜ 2.2. Ordenamiento por selecciÃ³n (Selection Sort)

Encuentra el **menor elemento** en cada pasada y lo coloca en su posiciÃ³n correcta.

```python
def selection_sort(lista):
    n = len(lista)
    for i in range(n):
        minimo = i
        for j in range(i + 1, n):
            if lista[j] < lista[minimo]:
                minimo = j
        lista[i], lista[minimo] = lista[minimo], lista[i]
    return lista

print(selection_sort([5, 3, 8, 1, 2]))  # [1, 2, 3, 5, 8]
```

ğŸ“ˆ **Complejidad:** O(nÂ²)

---

### ğŸ“˜ 2.3. Ordenamiento por inserciÃ³n (Insertion Sort)

Va insertando cada elemento en la posiciÃ³n correcta respecto a los anteriores (como ordenar cartas en la mano).

```python
def insertion_sort(lista):
    for i in range(1, len(lista)):
        valor_actual = lista[i]
        j = i - 1
        while j >= 0 and lista[j] > valor_actual:
            lista[j + 1] = lista[j]
            j -= 1
        lista[j + 1] = valor_actual
    return lista

print(insertion_sort([5, 3, 8, 1, 2]))  # [1, 2, 3, 5, 8]
```

ğŸ“ˆ **Complejidad:**
- Peor caso: O(nÂ²)
- Mejor caso: O(n)

---

### ğŸ“˜ 2.4. QuickSort (Ordenamiento rÃ¡pido)

Divide la lista en dos sublistas: elementos **menores** y **mayores** que un pivote.
Luego ordena recursivamente ambas partes.

```python
def quicksort(lista):
    if len(lista) <= 1:
        return lista
    pivote = lista[len(lista) // 2]
    menores = [x for x in lista if x < pivote]
    iguales = [x for x in lista if x == pivote]
    mayores = [x for x in lista if x > pivote]
    return quicksort(menores) + iguales + quicksort(mayores)

print(quicksort([5, 3, 8, 1, 2, 7, 4]))  # [1, 2, 3, 4, 5, 7, 8]
```

ğŸ“ˆ **Complejidad:**
- Promedio: O(n log n)
- Peor caso: O(nÂ²)

---

## ğŸ”¹ 3. ComparaciÃ³n general de algoritmos de ordenamiento

| Algoritmo | Tipo | Complejidad promedio | Estable | In-place | Ideal para |
|------------|-------|---------------------|----------|-----------|-------------|
| **Burbuja** | Comparativo | O(nÂ²) | âœ… | âœ… | EducaciÃ³n, ejemplos simples |
| **SelecciÃ³n** | Comparativo | O(nÂ²) | âŒ | âœ… | Listas pequeÃ±as |
| **InserciÃ³n** | Comparativo | O(nÂ²) | âœ… | âœ… | Listas casi ordenadas |
| **QuickSort** | Divide y vencerÃ¡s | O(n log n) | âŒ | âŒ | Grandes volÃºmenes de datos |
| **MergeSort** | Divide y vencerÃ¡s | O(n log n) | âœ… | âŒ | Listas grandes, estabilidad garantizada |

---

## ğŸ”¹ 4. Ejemplo integrador: bÃºsqueda y ordenamiento

```python
def quicksort(lista):
    if len(lista) <= 1:
        return lista
    pivote = lista[len(lista)//2]
    menores = [x for x in lista if x < pivote]
    iguales = [x for x in lista if x == pivote]
    mayores = [x for x in lista if x > pivote]
    return quicksort(menores) + iguales + quicksort(mayores)

def busqueda_binaria(lista, valor):
    inicio, fin = 0, len(lista) - 1
    while inicio <= fin:
        medio = (inicio + fin) // 2
        if lista[medio] == valor:
            return medio
        elif lista[medio] < valor:
            inicio = medio + 1
        else:
            fin = medio - 1
    return -1

datos = [9, 1, 7, 3, 2, 8, 4, 5, 6]
ordenados = quicksort(datos)
print("Lista ordenada:", ordenados)

indice = busqueda_binaria(ordenados, 7)
print("Elemento 7 encontrado en posiciÃ³n:", indice)
```

ğŸ“¤ **Salida esperada:**
```
Lista ordenada: [1, 2, 3, 4, 5, 6, 7, 8, 9]
Elemento 7 encontrado en posiciÃ³n: 6
```

---

## ğŸ”¹ 5. Otros algoritmos Ãºtiles y conocidos

| Algoritmo | DescripciÃ³n | Aplicaciones tÃ­picas |
|------------|-------------|----------------------|
| **Merge Sort** | Divide la lista y combina resultados ordenados | Ordenamiento eficiente y estable |
| **Heap Sort** | Utiliza una estructura heap para ordenar | Sistemas de prioridad, planificaciÃ³n |
| **Counting Sort** | Ordenamiento por conteo, sin comparaciones | Datos enteros limitados (por rango) |
| **Dijkstra** | Encuentra caminos mÃ¡s cortos en un grafo | NavegaciÃ³n, redes, logÃ­stica |
| **A*** | Variante heurÃ­stica de Dijkstra | Inteligencia artificial, juegos |
| **Kruskal / Prim** | Encuentran Ã¡rboles de expansiÃ³n mÃ­nima | Redes elÃ©ctricas, telecomunicaciones |
| **BFS (Breadth First Search)** | Recorre grafos por niveles | Rutas mÃ¡s cortas sin pesos |
| **DFS (Depth First Search)** | Recorre grafos en profundidad | ExploraciÃ³n, anÃ¡lisis estructural |
| **Binary Search Tree (BST)** | Estructura de bÃºsqueda ordenada | IndexaciÃ³n, bases de datos |
| **Dynamic Programming** | Divide problemas en subproblemas optimizados | OptimizaciÃ³n, IA, economÃ­a, bioinformÃ¡tica |

---

## ğŸ“– Recursos y referencias

- Cormen, T. H. et al. (2009). *Introduction to Algorithms*. MIT Press.
- Goodrich, M. T. & Tamassia, R. (2015). *Data Structures and Algorithms in Python*. Wiley.
- Downey, A. (2015). *Think Python*. Green Tea Press.
- Real Python â€“ [https://realpython.com/sorting-algorithms-python/](https://realpython.com/sorting-algorithms-python/)
- Python Official Docs â€“ [https://docs.python.org/3/howto/sorting.html](https://docs.python.org/3/howto/sorting.html)

---
