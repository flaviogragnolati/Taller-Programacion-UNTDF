# 🧩 Módulo 4: Estructuras de Datos y Algoritmos Básicos

## **Tema 4.2: List Comprehension, Recomendaciones y Otras Operaciones con Listas**

---

### 🧠 Introducción

Las **listas** son una de las estructuras más versátiles de Python.
A medida que se avanza en el lenguaje, aparecen formas más **compactas, expresivas y eficientes** de crearlas y manipularlas.

Una de las herramientas más poderosas para esto son las **list comprehensions**, que permiten generar listas de manera concisa y legible.

---

## 🔹 1. List Comprehension

Una **list comprehension** es una **forma abreviada** de construir listas en una sola línea, aplicando una **expresión** y opcionalmente **condiciones**.

### 📘 Sintaxis general:

```python
[expresion for elemento in iterable if condicion]
```

- `expresion`: operación o valor que se evaluará por cada elemento.
- `elemento`: variable temporal que recorre el iterable (por ejemplo, una lista o rango).
- `if condicion` *(opcional)*: filtra los elementos que cumplen la condición.

---

### 🧩 Ejemplo básico

```python
# Lista de cuadrados del 1 al 5
cuadrados = [x**2 for x in range(1, 6)]
print(cuadrados)  # [1, 4, 9, 16, 25]
```

---

### 🧮 Ejemplo con condición

```python
# Números pares del 0 al 10
pares = [x for x in range(11) if x % 2 == 0]
print(pares)  # [0, 2, 4, 6, 8, 10]
```

---

### 🔄 Ejemplo con transformación de texto

```python
nombres = ["ana", "LUIS", "Sofía"]
normalizados = [n.capitalize() for n in nombres]
print(normalizados)  # ['Ana', 'Luis', 'Sofía']
```

---

### ⚙️ Ejemplo con listas anidadas

```python
# Matriz 3x3
matriz = [[1, 2, 3], [4, 5, 6], [7, 8, 9]]

# Aplanar la matriz en una sola lista
plana = [num for fila in matriz for num in fila]
print(plana)  # [1, 2, 3, 4, 5, 6, 7, 8, 9]
```

---

## 🔹 2. Comprehensions análogas

Python también permite **comprehensions** con otras estructuras:

| Tipo | Sintaxis | Ejemplo |
|------|-----------|----------|
| **Set comprehension** | `{expresion for elemento in iterable}` | `{x**2 for x in range(5)}` |
| **Dict comprehension** | `{clave: valor for elemento in iterable}` | `{x: x**2 for x in range(5)}` |
| **Generator expression** | `(expresion for elemento in iterable)` | `(x**2 for x in range(5))` |

💡 **Diferencia clave:**
El **generator** no crea una lista en memoria, sino que **genera los valores uno a uno** (útil para grandes volúmenes de datos).

---

## 🔹 3. Otras operaciones y técnicas útiles con listas

### 🧰 3.1. Copia y referencia

```python
a = [1, 2, 3]
b = a        # referencia, ambos apuntan al mismo objeto
c = a.copy() # copia independiente

a.append(4)
print(a)  # [1, 2, 3, 4]
print(b)  # [1, 2, 3, 4]
print(c)  # [1, 2, 3]
```

📎 *Usar `copy()` o slicing `[:]` para evitar efectos colaterales entre listas compartidas.*

---

### 🧩 3.2. Slicing (segmentos de listas)

```python
nums = [0, 1, 2, 3, 4, 5, 6]

print(nums[1:4])   # [1, 2, 3]
print(nums[:3])    # [0, 1, 2]
print(nums[::2])   # [0, 2, 4, 6]
print(nums[::-1])  # [6, 5, 4, 3, 2, 1, 0] (inversión)
```

---

### ⚙️ 3.3. Unir y extender listas

```python
a = [1, 2, 3]
b = [4, 5]

# Concatenar
c = a + b           # [1, 2, 3, 4, 5]

# Extender
a.extend(b)
print(a)            # [1, 2, 3, 4, 5]
```

---

### 🧮 3.4. Funciones útiles con listas

| Función | Descripción | Ejemplo |
|----------|--------------|----------|
| `len(lista)` | Longitud de la lista | `len([1,2,3]) → 3` |
| `sum(lista)` | Suma de elementos numéricos | `sum([1,2,3]) → 6` |
| `max(lista)` / `min(lista)` | Máximo / mínimo | `max([3,7,2]) → 7` |
| `sorted(lista)` | Devuelve lista ordenada | `sorted([3,1,2]) → [1,2,3]` |
| `reversed(lista)` | Iterador en orden inverso | `list(reversed([1,2,3])) → [3,2,1]` |

---

## 🔹 4. Recomendaciones y buenas prácticas

✅ **Usar comprehensions** cuando:
- El código sea claro y legible.
- No haya lógica demasiado compleja o anidada.
- Se necesite crear una nueva lista transformada o filtrada.

⚠️ **Evitar comprehensions** cuando:
- La expresión sea larga o difícil de entender.
- Se necesiten múltiples condicionales o bucles anidados.
- Se requiera modificar elementos existentes (usar `for` tradicional).

💡 **Consejos adicionales:**
- Prefiere **comprehensions** sobre bucles `for` simples cuando sean expresivos.
- Para listas grandes, considera **generators** para ahorrar memoria.
- Usa **slicing** para copiar o invertir listas sin necesidad de bucles.
- Combina `zip()` y comprehensions para trabajar con varias listas a la vez:
  ```python
  nombres = ["Ana", "Luis", "Sofía"]
  notas = [9, 7, 10]
  resumen = [f"{n}: {c}" for n, c in zip(nombres, notas)]
  print(resumen)  # ['Ana: 9', 'Luis: 7', 'Sofía: 10']
  ```

---

## 🧩 Ejemplo integrador

Un ejemplo que combina **list comprehensions**, **condiciones** y **funciones integradas**:

```python
# Lista de ventas por vendedor
ventas = [
    {"nombre": "Ana", "monto": 1200},
    {"nombre": "Luis", "monto": 800},
    {"nombre": "Sofía", "monto": 1500},
    {"nombre": "Carlos", "monto": 500},
]

# Obtener lista de nombres con ventas mayores a 1000
destacados = [v["nombre"] for v in ventas if v["monto"] > 1000]
print("Vendedores destacados:", destacados)

# Promedio general
promedio = sum(v["monto"] for v in ventas) / len(ventas)
print("Promedio de ventas:", promedio)

# Clasificar ventas (alta/baja)
clasificacion = [
    {"nombre": v["nombre"], "nivel": "Alta" if v["monto"] > promedio else "Baja"}
    for v in ventas
]
print(clasificacion)
```

---

## 📚 Recursos útiles

- [Estructuras de datos — Python Docs (español)](https://docs.python.org/es/3/tutorial/datastructures.html#list-comprehensions)
- [Real Python – List Comprehensions in Python](https://realpython.com/list-comprehension-python/)

---